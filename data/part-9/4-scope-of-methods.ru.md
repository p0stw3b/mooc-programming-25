---
path: /ru/part-9/4-scope-of-methods
title: Область видимости методов
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, как в Python можно ограничить видимость метода
- вы сможете писать приватные методы

</text-box>

Методы, определённые в классе, можно скрывать точно так же, как атрибуты в предыдущем разделе. Если имя метода начинается с двух подчёркиваний `__`, клиент не сможет обратиться к нему напрямую.

Техника одинакова и для методов, и для атрибутов, но сценарии использования обычно разные. Приватные атрибуты часто сопровождаются геттерами и сеттерами, которые управляют доступом к ним. Приватные методы, напротив, обычно предназначены только для внутреннего использования — как вспомогательные методы для процессов, о которых клиенту знать не нужно.

Приватный метод можно использовать внутри класса так же, как и любой другой метод — разумеется, не забывая про `self`. Ниже приведён простой класс, представляющий получателя электронных писем. В нём есть приватный вспомогательный метод, который проверяет, что адрес email имеет корректный формат:

```python
class Recipient:
    def __init__(self, name: str, email: str):
        self.__name = name
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")

    def __check_email(self, email: str):
        # Простая проверка: адрес должен быть длиннее 5 символов
        # и содержать точку и символ @
        return len(email) > 5 and "." in email and "@" in email
```

Попытка вызвать приватный метод напрямую приводит к ошибке:

```python
peter = Recipient("Peter Emailer", "peter@example.com")
peter.__check_email("someone@example.com")
```

<sample-output>

AttributeError: 'Recipient' object has no attribute '__check_email'

</sample-output>

Внутри класса метод доступен как обычно, и логично использовать его и при установке нового значения адреса. Добавим геттер и сеттер для email‑адреса:

```python
class Recipient:
    def __init__(self, name: str, email: str):
        self.__name = name
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")

    def __check_email(self, email: str):
        # Простая проверка: адрес должен быть длиннее 5 символов
        # и содержать точку и символ @
        return len(email) > 5 and "." in email and "@" in email

    @property
    def email(self):
        return self.__email

    @email.setter
    def email(self, email: str):
        if self.__check_email(email):
            self.__email = email
        else:
            raise ValueError("The email address is not valid")
```

<text-box variant="info" name="Область видимости и пространства имён в Python">

Мы уже встречали термин _область видимости_ (scope) в [части 6](/ru/part-6/4-scope-of-variables) этих материалов и определяли его как участок программы, где видно имя (переменной). Если посмотреть на это с другой стороны, область видимости — это ещё и то, «что видно» из конкретной точки в коде. Другой связанный термин — _пространство имён_ (namespace): это набор имён, доступных внутри некоторой единицы Python, например внутри определения класса или функции.

Область видимости внутри метода отличается от области видимости внутри класса, а она, в свою очередь, отличается от области видимости в коде клиента, который создаёт экземпляр класса. Метод имеет доступ к своим локальным переменным, а также к атрибутам и другим методам класса, частью которого он является, даже если они приватные. Класс тоже «имеет» эти элементы (свои члены), но не может напрямую обращаться к локальным переменным внутри методов. Код клиента видит только публичные методы и атрибуты, определённые в классе, а также, конечно, другие имена в окружении, где он выполняется.

Может показаться странным, что класс не имеет доступа ко всему «внутреннему содержимому», но это важно для обеспечения целостности. Например, в разных методах одного класса может быть удобно использовать одинаковое имя локальной переменной, если методы делают что‑то похожее. Если бы класс мог напрямую обращаться ко всем локальным переменным из методов, их пришлось бы назвать по‑разному, иначе было бы непонятно, «какая версия» переменной используется где. Мы уже видели на примере атрибутов через `self`, что вспомогательные переменные не должны быть доступны вне метода, поэтому превращать их в атрибуты или глобальные переменные — плохой вариант. Нужен механизм, который разделяет имена в разных частях программы, и этим как раз занимаются пространства имён.

Идея пространства имён помогает понять, как одно и то же имя может спокойно сосуществовать в разных функциях, классах или модулях одновременно. Если имя относится к конкретному пространству имён (например, к определению метода), оно недоступно напрямую извне — поэтому ничто не мешает другому пространству имён использовать то же имя. Умение работать с областями видимости и пространствами имён — важная часть мастерства программиста, и на этом курсе у вас будет много практики.

</text-box>

## Нужен ли приватный метод? {#do-i-need-a-private-method}

В следующем примере класс `DeckOfCards` моделирует колоду из 52 карт. В нём есть вспомогательный метод `__reset_deck`, который создаёт новую перемешанную колоду. Сейчас приватный метод вызывается только в конструкторе, поэтому реализацию можно было бы поместить прямо туда. Однако отдельный метод делает код более читаемым и позволяет при необходимости использовать эту функциональность позже в других методах.

```python
from random import shuffle

class DeckOfCards:
    def __init__(self):
        self.__reset_deck()

    def __reset_deck(self):
        self.__deck = []
        # Добавляем все 52 карты в колоду
        suits = ["spades", "hearts", "clubs", "diamonds"]
        for suit in suits:
            for number in range(1, 14):
                self.__deck.append((suit, number))
        # Перемешиваем колоду
        shuffle(self.__deck)

    def deal(self, number_of_cards: int):
        hand = []
        # Перекладываем верхние карты из колоды в руку
        for i in range(number_of_cards):
            hand.append(self.__deck.pop())
        return hand
```

Проверим класс:

```python
deck = DeckOfCards()
hand1 = deck.deal(5)
print(hand1)
hand2 = deck.deal(5)
print(hand2)
```

Так как «руки» генерируются случайно, следующий вывод — лишь один из возможных примеров:

<sample-output>

[('spades', 7), ('spades', 11), ('hearts', 7), ('diamonds', 3), ('spades', 4)]
[('clubs', 8), ('spades', 12), ('diamonds', 13), ('clubs', 11), ('spades', 10)]

</sample-output>

Приватные методы в целом встречаются реже, чем приватные атрибуты. В качестве общего правила: метод стоит скрывать, если клиенту не нужно вызывать его напрямую. Особенно это актуально, если клиент, вызывая метод, может нарушить целостность объекта.

<programming-exercise name='Комиссия за обслуживание' anchor="Service charge" tmcname='part09-12_service_charge'>

Создайте класс `BankAccount`, который моделирует банковский счёт. В классе должны быть:

* конструктор, который принимает имя владельца (str), номер счёта (str) и баланс (float)
* метод `deposit(amount: float)` для внесения денег на счёт
* метод `withdraw(amount: float)` для снятия денег со счёта
* геттер `balance`, который возвращает баланс счёта

Кроме того, в классе должен быть приватный метод:

* `__service_charge()`, который уменьшает баланс на 1%. Каждый раз, когда вызывается `deposit` или `withdraw`, этот метод тоже должен вызываться. Комиссия рассчитывается и списывается только после того, как основная операция выполнена (то есть после того, как сумма была добавлена к балансу или вычтена из него).

Все атрибуты данных в определении класса должны быть приватными.

Для проверки класса можно использовать следующий код:

```python
account = BankAccount("Randy Riches", "12345-6789", 1000)
account.withdraw(100)
print(account.balance)
account.deposit(100)
print(account.balance)

```

<sample-output>

891.0
981.09

</sample-output>


</programming-exercise>
