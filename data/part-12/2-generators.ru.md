---
path: /ru/part-12/2-generators
title: Генераторы
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, что такое генератор в Python
- вы познакомитесь с ключевым словом `yield`
- вы сможете писать собственные функции‑генераторы

</text-box>

Мы уже сталкивались с ситуациями, когда работаем с последовательностью значений и нам нужен следующий элемент (или следующие элементы), но при этом не хочется каждый раз заново вычислять всю последовательность до нужного места. Хороший пример — рекурсивные последовательности, такие как числа Фибоначчи. Если каждый вызов функции рекурсивно генерирует всю последовательность до нужного места, начало последовательности будет вычисляться снова и снова.

Python‑_генераторы_ — это способ получать ровно следующий элемент последовательности тогда, когда он нужен, фактически выполняя процесс генерации только один раз (в рамках одного запуска программы). Они во многом похожи на обычные функции: их можно вызывать и получать значения, но то, что возвращает функция‑генератор, отличается от обычной функции. Обычная функция при одинаковых аргументах должна каждый раз возвращать одно и то же. Функция‑генератор, напротив, запоминает своё текущее состояние и возвращает следующий элемент последовательности, который может отличаться от предыдущего.

Как и для большинства задач программирования, существует много способов добиться поведения, похожего на генераторы, но генераторы помогают сделать программу понятнее и в некоторых случаях экономят память или другие вычислительные ресурсы.

## Ключевое слово yield {#the-keyword-yield}

Функция‑генератор должна содержать ключевое слово `yield`, которое указывает возвращаемое значение. Рассмотрим функцию, которая генерирует целые числа, начиная с нуля и заканчивая заранее заданным максимальным значением:

```python

def counter(max_value: int):
    number = 0
    while number <= max_value:
        yield number
        number += 1

```

Теперь функцию `counter` можно передать как аргумент функции `next()`:

```python
if __name__ == "__main__":
    numbers = counter(10)
    print("First value:")
    print(next(numbers))
    print("Second value:")
    print(next(numbers))
```

<sample-output>

First value:
0
Second value:
1

</sample-output>

Как видно из примера, ключевое слово `yield` похоже на `return`: оба задают возвращаемое значение. Разница в том, что `yield` не «закрывает» функцию так, как это делает `return`. Функция‑генератор с `yield` запоминает своё состояние, и при следующем обращении продолжит работу с того же места.

Этому генератору также нужен максимум, который в примере выше был равен `10`. Когда значения заканчиваются, генератор выбрасывает исключение `StopIteration`:

```python
if __name__ == "__main__":
    # создаём генератор с максимальным значением 1
    numbers = counter(1)
    print(next(numbers))
    print(next(numbers))
    print(next(numbers))
```

<sample-output>

0
1
Traceback (most recent call last):
  File "generator_example.py", line 11, in <module>
    print(next(numbers))
StopIteration

</sample-output>

Исключение можно перехватить с помощью блока `try` - `except`:

```python
if __name__ == "__main__":
    numbers = counter(1)
    try:
        print(next(numbers))
        print(next(numbers))
        print(next(numbers))
    except StopIteration:
        print("ran out of numbers")
```

<sample-output>

0
1
ran out of numbers

</sample-output>

Пройтись по всем значениям генератора легко с помощью цикла `for`:

```python
if __name__ == "__main__":
    numbers = counter(5)
    for number in numbers:
        print(number)
```

<sample-output>

0
1
2
3
4
5

</sample-output>

У генераторов не обязательно должна быть задана верхняя граница или точка завершения. Они могут генерировать значения бесконечно (разумеется, в пределах вычислительных и физических ограничений).

Но важно помнить: обход генератора в цикле `for` имеет смысл только тогда, когда генератор в какой‑то момент завершается. Если генератор построен на бесконечном цикле, попытка «пройтись» по нему простым `for` приведёт к бесконечному выполнению — так же, как и `while` без условия завершения или `break`.

<programming-exercise name='Чётные числа' anchor="Even numbers" tmcname='part12-08_even_numbers'>

Напишите функцию‑генератор `even_numbers(beginning: int, maximum: int)`, которая принимает два целых числа. Функция должна выдавать чётные числа, начиная с `beginning` и заканчивая числом не больше `maximum`.

Два примера работы функции:

```python
numbers = even_numbers(2, 10)
for number in numbers:
    print(number)
```

<sample-output>

2
4
6
8
10

</sample-output>

```python
numbers = even_numbers(11, 21)
for number in numbers:
    print(number)
```

<sample-output>

12
14
16
18
20

</sample-output>

</programming-exercise>

<programming-exercise name='Простые числа' anchor="Prime numbers" tmcname='part12-09_prime_numbers'>

Простое число — это число, которое делится только на себя и на 1. По соглашению простыми числами считаются положительные целые числа начиная с 2. Первые шесть простых чисел: 2, 3, 5, 7, 11 и 13.

Напишите функцию‑генератор `prime_numbers()`, которая создаёт новый генератор. Генератор должен возвращать простые числа по одному, по порядку, начиная с 2. Важно: этот генератор никогда не заканчивается — он будет генерировать числа столько, сколько нужно.

Например:

```python
numbers = prime_numbers()
for i in range(8):
    print(next(numbers))
```

<sample-output>

2
3
5
7
11
13
17
19

</sample-output>

**Подсказка:** можно проверять, является ли число простым, с помощью цикла. Если мы проверяем число `x`, цикл перебирает числа от `2` до `x-1`. Если `x` делится хотя бы на одно из них, то оно не является простым.

</programming-exercise>


## Генераторные выражения {#generator-comprehensions}

Чтобы создать генератор, не обязательно писать определение функции. Можно использовать конструкцию, похожую на списковое включение, только на этот раз мы используем _круглые_ скобки, чтобы обозначить генератор (а не список или словарь):

```python
# Этот генератор возвращает квадраты целых чисел
squares = (x ** 2 for x in range(1, 64))

print(squares) # вывод объекта‑генератора сам по себе не очень информативен

for i in range(5):
    print(next(squares))
```

<sample-output>

<generator object &lt;genexpr&gt; at 0x000002B4224EBFC0>
1
4
9
16
25

</sample-output>

В следующем примере печатаются подстроки английского алфавита длиной по три символа. Код ниже выводит первые 10 значений генератора:

```python
substrings = ("abcdefghijklmnopqrstuvwxyz"[i : i + 3] for i in range(24))

# выводим первые 10 подстрок
for i in range(10):
    print(next(substrings))
```

<sample-output>

abc
bcd
cde
def
efg
fgh
ghi
hij
ijk
jkl

</sample-output>

<programming-exercise name='Случайные слова' anchor="Random words" tmcname='part12-10_random_words'>

Напишите функцию `word_generator(characters: str, length: int, amount: int)`, которая возвращает новый генератор для создания случайных слов на основе переданных параметров.

Случайное слово генерируется так: из строки `characters` выбирается столько символов, сколько указано аргументом `length`. Один и тот же символ может встречаться в слове много раз.

Генератор возвращает столько слов, сколько указано аргументом `amount`, а затем завершается.

Пример запуска генератора слов:

```python
wordgen = word_generator("abcdefg", 3, 5)
for word in wordgen:
    print(word)
```

<sample-output>

dbf
baf
ead
fga
ccc

</sample-output>

Заметьте: способ реализации вы выбираете сами. Можно использовать как «классический» генератор, так и генераторное выражение.

</programming-exercise>
