---
path: /ru/part-6/4-scope-of-variables
title: Локальные и глобальные переменные
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, что такое локальная переменная
- вы поймёте, как область видимости переменной влияет на её использование
- вы будете знать, что означает ключевое слово Python `global`
- вы сможете применять локальные и глобальные переменные в подходящих случаях

</text-box>

_Область видимости_ (scope) переменной — это части программы, где к переменной можно обратиться. _Локальная_ переменная доступна только в определённом участке программы, а _глобальная_ переменная доступна в любой части программы.

## Локальные переменные {#local-variables}

Переменные, определённые внутри функции Python, являются локальными и доступны только внутри этой функции. Это касается и параметров функции, и других переменных, объявленных внутри тела функции. Переменная, локальная для функции, _не существует за пределами функции_.

В следующем примере мы пытаемся обратиться к переменной `x` в основной части программы, но это приводит к ошибке:

```python
def testing():
    x = 5
    print(x)

testing()
print(x)
```

<sample-output>

5
NameError: name 'x' is not defined

</sample-output>

Переменная `x` существует только во время выполнения функции `testing`. Другие функции и основная часть программы не могут получить к ней доступ.

## Глобальные переменные {#global-variables}

Переменные, определённые в основной части программы, являются глобальными. Ранее мы называли «основной частью» те участки кода Python‑программы, которые не находятся внутри какой‑либо функции. Значение глобальной переменной можно читать из любой функции, поэтому следующий пример не вызывает ошибок:

```python
def testing():
    print(x)

x = 3
testing()
```

<sample-output>

3

</sample-output>

Глобальную переменную нельзя изменить напрямую из другой функции (без дополнительных действий). Следующая функция _не влияет_ на значение глобальной переменной:

```python
def testing():
    x = 5
    print(x)

x = 3
testing()
print(x)
```

<sample-output>

5
3

</sample-output>

Здесь функция `testing` создаёт _новую локальную_ переменную `x`, которая «маскирует» глобальную переменную на время выполнения функции. Эта локальная переменная имеет значение 5, но это _другая_ переменная, не та глобальная `x`, которая определена в основной части программы.

А что произойдёт в следующем коде?

```python
def testing():
    print(x)
    x = 5

x = 3
testing()
print(x)
```

<sample-output>

UnboundLocalError: local variable 'x' referenced before assignment

</sample-output>


Функция `testing` присваивает значение переменной `x`, поэтому Python считает `x` локальной переменной (а не глобальной с тем же именем). Функция пытается обратиться к переменной до того, как она получила значение, поэтому возникает ошибка.

Если мы хотим явно указать, что внутри функции собираемся изменить глобальную переменную, понадобится ключевое слово Python `global`:

```python
def testing():
    global x
    x = 3
    print(x)

x = 5
testing()
print(x)
```

<sample-output>

3
3

</sample-output>

Теперь присваивание `x = 3` внутри функции влияет и на основную часть программы. Все участки программы используют одну и ту же глобальную переменную `x`.

## Когда стоит использовать глобальные переменные? {#when-should-you-use-global-variables}

Глобальные переменные — не способ обходить параметры функций или возвращаемые значения, и так их использовать не стоит. Да, технически _можно_ написать функцию, которая сохраняет результат прямо в глобальную переменную:

```python
def calculate_sum(a, b):
    global result
    result = a + b

calculate_sum(2, 3)
print(result)
```

Лучше писать функцию, которая возвращает значение — как мы уже привыкли:

```python
def calculate_sum(a, b):
    return a + b

result = calculate_sum(2, 3)
print(result)
```

Преимущество второго подхода в том, что функция — _самостоятельная_ единица: у неё есть чётко определённые параметры, и она возвращает результат. У неё нет побочных эффектов, поэтому её легче тестировать и менять независимо от остальной программы.

Глобальные переменные полезны в ситуациях, когда нужно иметь общую «верхнеуровневую» информацию, доступную всем функциям программы. Следующий пример показывает такую ситуацию:

```python
def calculate_sum(a, b):
    global count
    count += 1
    return a + b

def calculate_difference(a, b):
    global count
    count += 1
    return a - b


count = 0
print(calculate_sum(2, 3))
print(calculate_sum(5, 5))
print(calculate_difference(5, 2))
print(calculate_sum(1, 0))
print("There were", count, "function calls")
```

<sample-output>

5
10
3
1
There were 4 function calls

</sample-output>

Здесь мы хотим отслеживать, сколько раз за время выполнения программы были вызваны функции. Глобальная переменная `count` удобна: мы можем увеличивать её внутри функций при каждом вызове, а затем прочитать итоговое значение в основной части программы.

## Передача данных между функциями (ещё раз) {#passing-data-from-one-function-to-another-revisited}

<!--- см. также раздел 4-6: есть заметное пересечение-->
Если программа состоит из нескольких функций, часто возникает вопрос: как передавать данные из одной функции в другую.

Когда мы [уже обсуждали это](/ru/part-4/6-strings-and-lists#passing-data-from-one-function-to-another), у нас была программа, которая запрашивает у пользователя несколько целых чисел, выводит их и выполняет простую статистическую обработку. Программа была разделена на три функции:

```python
def input_from_user(how_many: int):
    print(f"Please type in {how_many} numbers:")
    numbers = []

    for i in range(how_many):
        number = int(input(f"Number {i+1}: "))
        numbers.append(number)

    return numbers

def print_result(numbers: list):
    print("The numbers are: ")
    for number in numbers:
        print(number)

def analyze(numbers: list):
    mean = sum(numbers) / len(numbers)
    return f"There are altogether {len(numbers)} numbers, the mean is {mean}, the smallest is {min(numbers)} and the greatest is {max(numbers)}"

# «главная функция», использующая эти функции
inputs = input_from_user(5)
print_result(inputs)
analysis_result = analyze(inputs)
print(analysis_result)
```

Пример выполнения программы:

<sample-output>

Please type in 5 numbers:
Number 1: 10
Number 2: 34
Number 3: -32
Number 4: 99
Number 5: -53
The numbers are:
10
34
-32
99
-53
There are altogether 5 numbers, the mean is 11.6, the smallest is -53 and the greatest is 99

</sample-output>

Основной принцип такой: «главная» часть программы хранит данные, с которыми работает программа. Здесь это числа, введённые пользователем, которые сохраняются в переменной `inputs`.

Если числа нужны какой‑то функции, переменная передаётся как аргумент — как в вызовах `print_result` и `analyze` выше. Если функция производит результат, который нужен дальше в программе, она возвращает его через `return` — как функции `input_from_user` и `analyze` в примере.

Как обычно в программировании, одного и того же результата можно добиться разными способами. Можно было бы использовать `global` и позволить функциям напрямую обращаться к переменной `inputs`, определённой в основной части программы. Однако есть веские причины, почему [это плохая идея](https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil). Когда множество функций могут напрямую читать и изменять одну переменную, становится сложно надёжно отслеживать состояние программы, и поведение может стать непредсказуемым. Это особенно заметно, когда функций много — что типично для крупных проектов.

Вывод: передавать данные в функции и из функций лучше всего через аргументы и возвращаемые значения.

Можно также вынести неявную «главную» часть примера в отдельную явную функцию `main`. Тогда переменная `inputs` перестанет быть глобальной и станет локальной внутри `main`:

```python
# здесь будет ваша функция main
def main():
    inputs = input_from_user(5)
    print_result(inputs)
    analysis_result = analyze(inputs)

    print(analysis_result)

# запускаем функцию main
main()
```

<!---
Тест для повторения материала этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->

Пожалуйста, ответьте на короткий опрос по материалам этой недели.

<quiz id="979b7162-29ef-5fd8-816b-cf1ff80eff23"></quiz>
