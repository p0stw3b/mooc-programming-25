---
path: /ru/part-6/3-errors
title: Обработка ошибок
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, как обрабатывать некорректный ввод
- вы поймёте, что такое исключения (exceptions) в программировании
- вы познакомитесь с наиболее распространёнными типами исключений в Python
- вы сможете обрабатывать исключения в собственных программах

</text-box>

В программировании можно выделить две основные категории ошибок:

1. Синтаксические ошибки, которые не дают программе запуститься
2. Ошибки времени выполнения (runtime errors), которые прерывают выполнение программы

Ошибки первой категории обычно легко исправить: интерпретатор Python укажет место ошибки при попытке запуска. К типичным синтаксическим ошибкам относятся, например, отсутствие двоеточия в конце строки заголовка или пропущенная кавычка в конце строки.

Ошибки второй категории сложнее заметить: бывает, что они проявляются только в определённый момент выполнения и лишь при некоторых условиях. Программа может работать нормально в большинстве случаев, но остановиться из‑за ошибки в каком‑то редком «краевом» сценарии. В этом разделе мы сосредоточимся на обработке ошибок времени выполнения.

## Проверка корректности ввода {#input-validation}

Многие ошибки, возникающие во время выполнения программы, связаны с некорректными входными данными. Например:

* отсутствующие или пустые значения в обязательных полях, например пустая строка там, где важна длина строки
* отрицательные значения там, где допускаются только положительные, например -15 как количество ингредиента в рецепте
* отсутствие файла или опечатка в имени файла
* слишком маленькие или слишком большие значения — например при работе с датами и временем
* неверные индексы, например попытка обратиться к индексу 3 в строке `"hey"`
* значения неправильного типа, например строка там, где ожидается целое число

К счастью, как программисты мы можем предусмотреть большинство подобных ошибок. Посмотрим на программу, которая спрашивает возраст и проверяет, что введено допустимое значение (в данном случае от 0 до 150):

```python
age = int(input("Please type in your age: "))
if age >= 0 and age <= 150:
    print("That is a fine age")
else:
    print("This is not a valid age")
```

<sample-output>

Please type in your age: **25**
That is a fine age

</sample-output>

<sample-output>

Please type in your age: **-3**
This is not a valid age

</sample-output>

Пока пользователь вводит целое число, проверка работает нормально. Но что будет, если ввести строку?

<sample-output>

Please type in your age: **twenty-three**
ValueError: invalid literal for int() with base 10: 'twenty-three'

</sample-output>

Функция `int` не может преобразовать строку `twenty-three` в целое число. Выполнение программы прерывается, и выводится сообщение об ошибке.

## Исключения {#exceptions}

Ошибки, возникающие во время выполнения программы, называются _исключениями_ (exceptions). К исключениям можно подготовиться и обработать их так, чтобы программа продолжала работать, даже если ошибка возникла.

В Python исключения обрабатываются с помощью конструкций `try` и `except`. Идея такая: если внутри блока `try` возникает исключение, Python проверяет, есть ли подходящий блок `except`. Если есть — выполняется этот блок, после чего программа продолжает работу.

Изменим предыдущий пример так, чтобы программа была готова к исключению `ValueError`:

```python
try:
    age = int(input("Please type in your age: "))
except ValueError:
    age = -1

if age >= 0 and age <= 150:
    print("That is a fine age")
else:
    print("This is not a valid age")
```

<sample-output>

Please type in your age: **twenty-three**
This is not a valid age

</sample-output>

Блок `try` показывает, что код внутри может вызвать ошибку. В `except`, расположенном сразу после блока, указывается тип ошибки, которую мы хотим перехватить. В примере выше мы обрабатываем только `ValueError`. Если бы возникло исключение другого типа, выполнение всё равно было бы прервано, несмотря на наличие `try` и `except`.

В примере выше, если ошибка перехвачена, переменной `age` присваивается значение -1. Это некорректный ввод, для которого у нас уже описано поведение — программа ожидает, что возраст будет больше 0.

В следующем примере есть функция `read_integer`, которая просит пользователя ввести целое число, и при этом готова к некорректному вводу. Функция продолжает спрашивать, пока пользователь не введёт корректное значение.

```python
def read_integer():
    while True:
        try:
            input_str = input("Please type in an integer: ")
            return int(input_str)
        except ValueError:
            print("This input is invalid")

number = read_integer()
print("Thank you!")
print(number, "to the power of three is", number**3)
```

<sample-output>

Please type in an integer: **three**
This input is invalid
Please type in an integer: **aybabtu**
This input is invalid
Please type in an integer: **5**
Thank you!
5 to the power of three is 125

</sample-output>

Иногда достаточно перехватить исключение конструкцией `try`–`except`, ничего не делая с ним. То есть можно просто «проигнорировать» ситуацию в блоке `except`.

Если изменить пример так, чтобы принимались только числа меньше 100, может получиться так:

```python
def read_small_integer():
    while True:
        try:
            input_str = input("Please type in an integer: ")
            number = int(input_str)
            if number < 100:
                return number
        except ValueError:
            pass # эта команда на самом деле ничего не делает

        print("This input is invalid")

number = read_small_integer()
print(number, "to the power of three is", number**3)
```

<sample-output>

Please type in an integer: **three**
This input is invalid
Please type in an integer: **1000**
This input is invalid
Please type in an integer: **5**
Thank you!
5 to the power of three is 125

</sample-output>

Теперь блок `except` содержит только команду `pass`, которая ничего не делает. Python не разрешает пустые блоки, поэтому эта команда необходима.

<programming-exercise name='Чтение ввода' anchor="Reading input" tmcname='part06-17_read_input'>

Напишите функцию `read_input`, которая запрашивает ввод у пользователя до тех пор, пока пользователь не введёт целое число, попадающее в диапазон, заданный аргументами функции. Функция должна вернуть последнее корректное целое число, введённое пользователем.

Пример работы функции:

```python
number = read_input("Please type in a number: ", 5, 10)
print("You typed in:", number)
```

<sample-output>

Please type in a number: **seven**
You must type in an integer between 5 and 10
Please type in a number: **-3**
You must type in an integer between 5 and 10
Please type in a number: **8**
You typed in: 8

</sample-output>

</programming-exercise>

## Типичные ошибки {#typical-errors}

Ниже приведены несколько типичных ошибок, с которыми вы, вероятно, столкнётесь, а также примеры ситуаций, когда они возникают.

**ValueError**

Эта ошибка часто возникает, когда аргумент, переданный функции, по какой‑то причине некорректен. Например, вызов `float("1,23")` вызывает ошибку, потому что в Python дробная часть отделяется точкой, а здесь используется запятая.

**TypeError**

Эта ошибка возникает, когда значение имеет неправильный тип. Например, вызов `len(10)` приводит к `TypeError`, потому что функция `len` ожидает значение, длину которого можно вычислить, например строку или список.

**IndexError**

Эта распространённая ошибка возникает при попытке обратиться к индексу, которого не существует. Например, выражение `"abc"[5]` вызывает `IndexError`, потому что в строке нет индекса 5.

**ZeroDivisionError**

Как следует из названия, эта ошибка возникает при попытке деления на ноль — а мы знаем из математики, что это всегда плохая идея. Например, если попытаться вычислить среднее арифметическое элементов списка по формуле `sum(my_list) / len(my_list)`, но список пуст (его длина равна нулю), возникнет эта ошибка.

**Исключения при работе с файлами**

Типичные ошибки при работе с файлами — это **FileNotFoundError** (когда пытаемся открыть файл, которого не существует), **io.UnsupportedOperation** (когда пытаемся выполнить операцию, не поддерживаемую режимом открытия файла) и **PermissionError** (у программы нет прав доступа к файлу).

## Обработка нескольких исключений {#handling-multiple-exceptions-at-once}

К одному блоку `try` можно прикрепить несколько блоков `except`. Например, следующая программа обрабатывает и `FileNotFoundError`, и `PermissionError`:

```python
try:
    with open("example.txt") as my_file:
        for line in my_file:
            print(line)
except FileNotFoundError:
    print("The file example.txt was not found")
except PermissionError:
    print("No permission to access the file example.txt")
```

Иногда не обязательно указывать конкретный тип ошибки, к которой готовится программа. Особенно при работе с файлами часто достаточно знать, что произошла ошибка, и корректно завершить выполнение. Не всегда нужно понимать, _почему_ именно возникла ошибка. Если нужно перехватить все возможные исключения, можно использовать `except` без указания типа:

```python

try:
    with open("example.txt") as my_file:
        for line in my_file:
            print(line)
except:
    print("There was an error when reading the file.")

```

Важно: `except` в таком виде перехватывает все возможные ошибки, включая те, которые вызваны ошибками программиста. Не будут перехвачены только синтаксические ошибки — они мешают коду запуститься.

Например, следующая программа всегда будет выводить сообщение об ошибке, потому что имя переменной `my_file` на третьей строке написано как `myfile`.

```python
try:
    with open("example.txt") as my_file:
        for line in myfile:
            print(line)
except:
    print("There was an error when reading the file.")
```

Блок `except` может скрывать настоящую причину ошибки: здесь проблема не в работе с файлом, а в опечатке в имени переменной. Без `except` было бы показано реальное исключение, и найти причину было бы проще. Поэтому обычно лучше использовать `except`, явно указывая типы ошибок, которые вы хотите обработать.

## Передача исключений {#passing-exceptions}

Если при выполнении функции возникает исключение и оно не обработано, исключение «поднимается» вверх по цепочке вызовов: в код, который вызвал эту функцию, затем ещё выше — пока не достигнет уровня основной части программы. Если и там оно не будет обработано, выполнение программы остановится, и исключение обычно будет выведено пользователю.

В следующем примере есть функция `testing`. Если она вызывает исключение, оно обрабатывается не внутри функции, а в основной части программы:

```python
def testing(x):
    print(int(x) + 1)

try:
    number = input("Please type in a number: ")
    testing(number)
except:
    print("Something went wrong")
```

<sample-output>

Please type in a number: **three**
Something went wrong

</sample-output>

## Генерация исключений {#raising-exceptions}

Исключения можно не только перехватывать, но и «выбрасывать» (raise) с помощью команды `raise`. Может показаться странным специально вызывать ошибки в своей программе, но на практике это очень полезный механизм.

Например, иногда стоит возбуждать ошибку при обнаружении некорректных параметров. До сих пор при проверке ввода мы часто просто печатали сообщения, но если функция вызывается из другого места, вывод может остаться незамеченным. Генерация исключения делает проблему явной и упрощает отладку.

В следующем примере есть функция, вычисляющая факториал (например, факториал числа 5 — это 1 * 2 * 3 * 4 * 5). Если аргумент функции отрицательный, функция возбуждает ошибку:

```python
def factorial(n):
    if n < 0:
        raise ValueError("The input was negative: " + str(n))
    k = 1
    for i in range(2, n + 1):
        k *= i
    return k

print(factorial(3))
print(factorial(6))
print(factorial(-1))
```

<sample-output>

6
720
Traceback (most recent call last):
  File "test.py", line 11, in <module>
    print(factorial(-1))
  File "test.py", line 3, in factorial
    raise ValueError("The input was negative: " + str(n))
ValueError: The input was negative: -1

</sample-output>


<programming-exercise name='Проверка параметров' anchor="Parameter validation" tmcname='part06-18_parameter_validation'>

Напишите функцию `new_person(name: str, age: int)`, которая создаёт и возвращает кортеж из данных аргументов. Первый элемент — имя, второй — возраст.

Если значения аргументов некорректны, функция должна возбуждать исключение `ValueError`.

Некорректные параметры в этом задании:

* `name` — пустая строка
* `name` содержит меньше двух слов
* `name` длиннее 40 символов
* `age` — отрицательное число
* `age` больше 150

</programming-exercise>

<programming-exercise name='Некорректные лотерейные номера' anchor="Incorrect lottery numbers" tmcname='part06-19_incorrect_lottery_numbers'>

Файл `lottery_numbers.csv` содержит выигрышные лотерейные номера в следующем формате:

<sample-data>

week 1;5,7,11,13,23,24,30
week 2;9,13,14,24,34,35,37
...и так далее...

</sample-data>

Каждая строка должна начинаться с заголовка `week x`, после которого идут семь целых чисел — все в диапазоне от 1 до 39 включительно.

Файл повреждён. Строки могут содержать следующие типы ошибок (эти конкретные строки могут не встречаться, но ошибки аналогичного вида будут):

Неверный номер недели:

<sample-data>

week zzc;1,5,13,22,24,25,26

</sample-data>

Одно или несколько чисел некорректны:

<sample-data>

week 22;1,**,5,6,13,2b,34

</sample-data>

Слишком мало чисел:

<sample-data>

week 13;4,6,17,19,24,33

</sample-data>

Числа слишком маленькие или слишком большие:

<sample-data>

week 39;5,9,15,35,39,41,105

</sample-data>

Одно и то же число встречается дважды:

<sample-data>

week 41;5,12,3,35,12,14,36

</sample-data>

Напишите функцию `filter_incorrect()`, которая создаёт файл `correct_numbers.csv`. В этот файл должны попасть только те строки исходного файла, которые записаны в корректном формате.

</programming-exercise>

<!---
Тест для повторения материала этого раздела:

<quiz id="69694e01-4c47-5b9d-8a00-b0d96a477dc7"></quiz>
-->
