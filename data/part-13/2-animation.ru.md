---
path: /ru/part-13/2-animation
title: Анимация
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, как делать анимацию с pygame
- вы сможете использовать таймер (clock), чтобы задавать скорость программы
- вы сможете применять базовые тригонометрические функции в анимациях

</text-box>

Во многих играх есть движущиеся персонажи, поэтому логичный следующий шаг — создание анимаций. Иллюзию движения можно получить, если рисовать одно и то же изображение в разных местах экрана и правильно задавать темп обновления.

## Создание анимации {#creating-an-animation}

Следующий код создаёт анимацию, в которой робот движется слева направо в окне pygame:

```python
import pygame

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

x = 0
y = 0
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()

    x += 1
    clock.tick(60)
```

При запуске результат должен выглядеть так:

<img src="pygame_animation.gif">

Разберёмся, какие команды здесь используются. Чтобы отслеживать движение изображения на экране, нужно знать его координаты, поэтому у нас есть две переменные для координат верхнего левого угла изображения:

```python
x = 0
y = 0
```

Также есть таймер (clock), который мы используем, чтобы скорость анимации была правильной:

```python
clock = pygame.time.Clock()
```

Главный цикл на каждой итерации рисует изображение в текущем месте:

```python
    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()
```

Сначала метод `fill` заполняет окно чёрным цветом, как и раньше. Цвет передаётся в виде кортежа с RGB‑значениями. В данном случае аргумент `(0, 0, 0)` означает, что все три компоненты — красная, зелёная и синяя — равны 0. Каждая компонента может принимать значение от 0 до 255. Например, `(255, 255, 255)` даст белый цвет, а `(255, 0, 0)` — красный. RGB‑коды — основа цифровых цветов; в интернете есть множество инструментов для работы с ними, например [RGB Color Codes Chart](https://www.rapidtables.com/web/color/RGB_Color.html).

После заливки окна цветом изображение рисуется в заданной точке методом `blit`. Затем содержимое окна обновляется функцией `pygame.display.flip`.

Затем значение `x` увеличивается, и изображение сдвигается на один пиксель вправо на каждой итерации:

```python
    x += 1
```

В конце вызывается метод таймера `tick`:

```python
    clock.tick(60)
```

Метод `tick` отвечает за скорость анимации. Аргумент `60` означает, что цикл должен выполняться 60 раз в секунду, то есть изображение будет смещаться на 60 пикселей вправо за секунду. Это примерно соответствует значению _FPS_ (frames per second), которое используется в играх.

В целом `tick` делает так, чтобы анимация работала с одинаковой скоростью на разных компьютерах. Если бы ограничения по времени не было, скорость анимации зависела бы от производительности компьютера.

## Отскок от стены {#bouncing-off-a-wall}

Предыдущая анимация была бы отличной, но когда робот достиг стены, он просто продолжил двигаться и исчез из окна. Сделаем так, чтобы робот отскакивал от стены.

```python
import pygame

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

x = 0
y = 0
velocity = 1
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()
    
    x += velocity
    if velocity > 0 and x+robot.get_width() >= 640:
        velocity = -velocity
    if velocity < 0 and x <= 0:
        velocity = -velocity

    clock.tick(60)
```

Запуск кода выше должен выглядеть так:

<img src="pygame_animation2.gif">

Появилась новая переменная `velocity`, которая задаёт направление движения. Если значение больше нуля — движение вправо, если меньше нуля — влево. В данном случае при `1` робот двигается вправо, а при `-1` — влево.

Следующие строки заставляют робота «отскакивать» от боковых стен:

```python
    if velocity > 0 and x+robot.get_width() >= 640:
        velocity = -velocity
    if velocity < 0 and x <= 0:
        velocity = -velocity
```

Если `velocity` больше нуля (робот движется вправо) и правая граница изображения выходит за правую границу окна, направление меняется, и робот начинает двигаться влево. Аналогично, если `velocity` меньше нуля (робот движется влево) и левая граница изображения достигает левой границы окна, направление снова меняется, и робот начинает двигаться вправо.

В итоге робот бесконечно двигается от левого края окна к правому и обратно.

## Вращение {#rotation}

Сделаем ещё одну анимацию. На этот раз робот будет двигаться _по окружности_ вокруг центра окна:

```python
import pygame
import math

pygame.init()
window = pygame.display.set_mode((640, 480))

robot = pygame.image.load("robot.png")

angle = 0
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit()

    x = 320+math.cos(angle)*100-robot.get_width()/2
    y = 240+math.sin(angle)*100-robot.get_height()/2

    window.fill((0, 0, 0))
    window.blit(robot, (x, y))
    pygame.display.flip()

    angle += 0.01
    clock.tick(60)
```

Запуск кода выше должен выглядеть так:

<img src="pygame_rotation.gif">

Движение по довольно точной окружности достигается с помощью базовых тригонометрических функций. Переменная `angle` хранит угол положения робота относительно центра окна и горизонтальной линии, проходящей через центр. Для вычисления координат используются синус и косинус из модуля `math`:

```python
        x = 320+math.cos(angle)*100-robot.get_width()/2
        y = 240+math.sin(angle)*100-robot.get_height()/2
```

Робот движется по окружности радиуса 100 вокруг центра окна. В такой геометрической интерпретации гипотенуза — это радиус окружности. Косинус даёт длину _прилежащего_ катета по отношению к гипотенузе — то есть компоненту `x`. Синус даёт длину _противолежащего_ катета — компоненту `y`. Затем координаты корректируются с учётом размеров изображения так, чтобы центр окружности совпадал с центром окна.

На каждой итерации значение `angle` увеличивается на 0.01. Так как мы используем радианы, полный круг — это `2π`, то есть примерно 6.28. Роботу нужно примерно 628 итераций, чтобы сделать полный оборот, и при 60 итерациях в секунду это занимает чуть больше 10 секунд.

<programming-exercise name='Вертикальное движение' anchor="Vertical movement" tmcname='part13-05_vertical_movement'>

Создайте анимацию, в которой робот бесконечно движется вверх и вниз. Итог должен выглядеть так:

<img src="pygame_vertical.gif">

</programming-exercise>

<programming-exercise name='По периметру' anchor="Round the perimeter" tmcname='part13-06_round_the_perimeter'>

Создайте анимацию, в которой робот движется по периметру окна. Итог должен выглядеть так:

<img src="pygame_perimeter.gif">

</programming-exercise>

<programming-exercise name='Два робота' anchor="Two robots" tmcname='part13-07_two_robots'>

Создайте анимацию, в которой два робота движутся туда‑сюда влево и вправо. Нижний робот должен двигаться вдвое быстрее верхнего. Итог должен выглядеть так:

<img src="pygame_move2.gif">

</programming-exercise>

<programming-exercise name='Роботы по кругу' anchor="Robots in a circle" tmcname='part13-08_robot_circle'>

Создайте анимацию, в которой десять роботов движутся по кругу. Итог должен выглядеть так:

<img src="pygame_circle.gif">

</programming-exercise>

<programming-exercise name='Прыгающий мяч' anchor="Bouncing ball" tmcname='part13-09_bouncing_ball'>

Создайте анимацию, в которой мяч отскакивает от границ окна. Итог должен выглядеть так:

<img src="pygame_bounce.gif">

В шаблоне упражнения есть изображение `ball.png`.

</programming-exercise>

<programming-exercise name='Нашествие роботов' anchor="Robot invasion" tmcname='part13-10_robot_invasion'>

Создайте анимацию, в которой роботы случайным образом падают с неба. Когда робот достигает земли, он начинает двигаться влево или вправо и в конце концов исчезает за пределами экрана. Итог должен выглядеть так:

<img src="pygame_invasion.gif">

</programming-exercise>
