---
path: /ru/part-8/1-objects-and-methods
title: Объекты и методы
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, что такое объект в программировании
- вы поймёте, что означает независимость отдельных объектов
- вы сможете создавать объекты и получать доступ к их данным

</text-box>

Это первая часть «Продвинутого курса программирования». Материалы рассчитаны на работу в редакторе Visual Studio Code, как и предыдущий курс «Введение в программирование». Если вы ещё не использовали Visual Studio Code, инструкции по установке находятся [здесь](https://www.mooc.fi/en/installation/vscode), а введение в среду разработки из предыдущего курса — [здесь](/ru/part-4/1-vscode).

В курсе «Введение в программирование» мы заметили, что часто имеет смысл группировать связанные данные. Например, если мы хотим хранить информацию о книге, удобно использовать кортеж или словарь, чтобы собрать данные в одну структуру.

Такое решение с кортежем может выглядеть так:

```python
name = "In Search of Lost Typing"
author = "Marcel Pythons"
year = 1992

# Объединим это в кортеж
book = (name, author, year)

# Выведем название книги
print(book[0])
```

В подобной ситуации преимущество словаря в том, что в качестве ключей можно использовать строки вместо индексов. То есть можно дать элементам структуры «говорящие» имена:

```python
name = "In Search of Lost Typing"
author = "Marcel Pythons"
year = 1992

# Объединим это в словарь
book = {"name": name, "author": author, "year": year}

# Выведем название книги
print(book["name"])
```

В обоих случаях мы создаём новый _объект_. В программировании это слово означает независимое целое, которое, например, хранит набор связанных данных. Независимость означает, что изменения одного объекта не влияют на другие объекты.

Если создать две структурно одинаковые «книги» (словари с одинаковыми ключами), любые изменения в одном словаре не повлияют на другой:

```python
book1 = {"name": "The Old Man and the Pythons", "author": "Ernest Pythons", "year": 1952}
book2 = {"name": "Seven Pythons", "author": "Aleksis Python", "year": 1894}

print(book1["name"])
print(book2["name"])

book1["name"] = "A Farewell to ARM Processors"

print(book1["name"])
print(book2["name"])
```

<sample-output>

The Old Man and the Pythons
Seven Pythons
A Farewell to ARM Processors
Seven Pythons

</sample-output>

<img src="8_1_1.png">

<text-box variant="info" name="Объекты в Python">

Вы можете помнить из курса «Введение в программирование», что любое значение в Python внутренне представлено как объект. Это означает, что значение, хранящееся в переменной, — это _ссылка на объект_. Сами данные хранятся внутри объекта в памяти. Если вы пишете `a = 3`, то в переменной `a` хранится _не_ число 3 «напрямую», а _ссылка на объект, содержащий значение 3_.

Во многих других языках (по крайней мере в тех, где есть ООП) существуют специально определённые _примитивные типы данных_. Обычно это как минимум целые числа, числа с плавающей точкой и булевы значения. Примитивы обрабатываются «напрямую»: значение хранится непосредственно в переменной, а не как ссылка. В Python таких примитивов нет, хотя работать с базовыми типами на практике похоже. Объекты базовых типов (например числа, булевы значения и строки) _неизменяемы_ (immutable) — их нельзя изменить «на месте» в памяти. Если нужно «изменить» значение переменной базового типа, меняется ссылка (переменная начинает ссылаться на другой объект), а исходный объект остаётся неизменным.

</text-box>

## Объекты и методы {#objects-and-methods}

К данным объекта можно обращаться через _методы_. Метод — это функция, которая работает с конкретным объектом, к которому она «прикреплена». Методы отличаются от обычных функций тем, как они вызываются: сначала пишется имя объекта, затем точка, затем имя метода (и при необходимости аргументы). Например, метод `values` возвращает все значения, хранящиеся в словаре (`dict`):

```python
# создаём словарь (объект типа dict) с именем book
book = {"name": "The Old Man and the Pythons", "author": "Ernest Pythons", "year": 1952}

# Выведем все значения
# Вызов метода values() пишется после имени переменной
# Помните про точечную нотацию!
for value in book.values():
    print(value)
```

<sample-output>

The Old Man and the Pythons
Ernest Pythons
1952

</sample-output>

Точно так же работают и методы строк: они вызываются у конкретного строкового объекта. Примеры строковых методов — `count` и `find`:

```python
name = "Imaginary Irene"

# Выведем, сколько раз встречается буква I
print(name.count("I"))

# Сколько букв I в другой строке
print("Irreverent Irises in Islington".count("I"))

# Индекс подстроки Irene
print(name.find("Irene"))

# В этой строке такой подстроки нет
print("A completely different string".find("Irene"))
```

<sample-output>

2
3
10
-1

</sample-output>

Методы строк возвращают значения, но не изменяют содержимое строки. Как мы уже сказали, строки в Python неизменяемы. Однако это справедливо не для всех типов: списки в Python изменяемы, поэтому методы списков могут изменять список, у которого они вызываются:

```python
my_list = [1,2,3]

# Добавим пару элементов
my_list.append(5)
my_list.append(1)

print(my_list)

# Удалим первый элемент
my_list.pop(0)

print(my_list)
```

<sample-output>

[1, 2, 3, 5, 1]
[2, 3, 5, 1]

</sample-output>

<programming-exercise name='Наименьший средний результат' anchor="The smallest average result" tmcname='part08-01_smallest_average'>

Напишите функцию `smallest_average(person1: dict, person2: dict, person3: dict)`, которая принимает три словаря.

Каждый словарь содержит значения по следующим ключам:

* `"name"`: имя участника
* `"result1"`: первый результат участника (целое число от 1 до 10)
* `"result2"`: второй результат участника (аналогично)
* `"result3"`: третий результат участника (аналогично)

Функция должна вычислить среднее из трёх результатов для каждого участника и вернуть участника с наименьшим средним значением. Возвращаемым значением должен быть целиком словарь с информацией об этом участнике.

Можно считать, что ничьей не будет: только у одного участника будет наименьший средний результат.

Пример работы функции:

```python
person1 = {"name": "Mary", "result1": 2, "result2": 3, "result3": 3}
person2 = {"name": "Gary", "result1": 5, "result2": 1, "result3": 8}
person3 = {"name": "Larry", "result1": 3, "result2": 1, "result3": 1}

print(smallest_average(person1, person2, person3))
```

<sample-output>

{'name': 'Larry', 'result1': 3, 'result2': 1, 'result3': 1}

</sample-output>

</programming-exercise>

<programming-exercise name='Суммы строк' anchor="Row sums" tmcname='part08-02_row_sums '>

В Python любое значение в переменной — это ссылка на объект, поэтому и значения в списке тоже являются ссылками на объекты. То же самое верно и для «матрицы», представленной как список списков: каждый элемент верхнего списка — ссылка на другой список, который, в свою очередь, содержит ссылки на объекты‑элементы матрицы.

Напишите функцию `row_sums(my_matrix: list)`, которая принимает целочисленную матрицу (список списков).

Функция должна добавить в каждую строку матрицы новый элемент — сумму остальных элементов этой строки. Функция ничего не возвращает и должна изменить матрицу прямо «на месте».

Пример работы функции:

```python
my_matrix = [[1, 2], [3, 4]]
row_sums(my_matrix)
print(my_matrix)
```

<sample-output>

[[1, 2, 3], [3, 4, 7]]

</sample-output>

</programming-exercise>
