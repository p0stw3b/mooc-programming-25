---
path: /ru/part-14/2-robot-and-boxes
title: Робот и ящики
hidden: false
---

В Sokoban‑подобных играх чаще всего самое сложное — реализовать движение робота так, чтобы он мог толкать коробки в нужном направлении. Игра должна уметь определять, может ли робот сделать ход в указанную сторону, и корректно обрабатывать ситуации, когда вместе с роботом должна сдвинуться коробка. Давайте решим эту задачу.

## Обработка нажатий клавиш {#handling-key-events}

Игрок управляет роботом четырьмя стрелками, поэтому обработчик событий должен реагировать на соответствующие нажатия:

```python
    def check_events(self):
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    self.move(0, -1)
                if event.key == pygame.K_RIGHT:
                    self.move(0, 1)
                if event.key == pygame.K_UP:
                    self.move(-1, 0)
                if event.key == pygame.K_DOWN:
                    self.move(1, 0)

            if event.type == pygame.QUIT:
                exit()
```

Теперь при нажатии стрелки вызывается метод `move` с парой аргументов. Первый аргумент задаёт смещение по вертикали, а второй — по горизонтали.

## Поиск робота {#searching-for-the-robot}

Чтобы двигать робота, игра должна знать его текущее положение. Добавим метод `find_robot`, который находит координаты робота:

```python
    def find_robot(self ):
        for y in range(self.height):
            for x in range(self.width):
                if self.map[y][x] in [4, 6]:
                    return (y, x)
```

Метод проходит по всем клеткам игрового поля и возвращает координаты клетки, которая содержит либо число 4 (робот на обычной клетке), либо число 6 (робот на клетке цели).

Идея в том, что при каждом нажатии стрелки мы сначала определяем положение робота, проходя по клеткам. Это может показаться медленным и лишним, ведь можно хранить координаты робота в отдельных переменных. Однако у подхода с поиском есть плюс: координаты робота не дублируются (в сетке _и_ в отдельных переменных), а значит нам нужно поддерживать в актуальном состоянии только один «источник истины» — саму сетку. Состояние игры в памяти становится проще.

## Изменения игрового поля {#changes-to-the-game-grid}

Выше мы уже вызывали метод `move`, но пока его не определили. Сделаем это сейчас.

Метод `move` принимает направление хода (смещение по `y` и `x`). Затем он либо обновляет сетку игрового поля, либо определяет, что ход невозможен, и оставляет поле без изменений.

```python
    def move(self, move_y, move_x):
        robot_old_y, robot_old_x = self.find_robot() 
        robot_new_y = robot_old_y + move_y
        robot_new_x = robot_old_x + move_x

        if self.map[robot_new_y][robot_new_x] == 1:
            return

        if self.map[robot_new_y][robot_new_x] in [3, 5]:
            box_new_y = robot_new_y + move_y
            box_new_x = robot_new_x + move_x

            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
                return

            self.map[robot_new_y][robot_new_x] -= 3
            self.map[box_new_y][box_new_x] += 3

        self.map[robot_old_y][robot_old_x] -= 4
        self.map[robot_new_y][robot_new_x] += 4
```

В методе несколько этапов, поэтому рассмотрим каждый по очереди:

### Старое и новое положение робота {#the-old-and-new-location-of-the-robot}

```python
        robot_old_y, robot_old_x = self.find_robot() 
        robot_new_y = robot_old_y + move_y
        robot_new_x = robot_old_x + move_x
```

Сначала метод вызывает `find_robot`, чтобы найти текущее положение робота до хода. Эти координаты сохраняются в `robot_old_y` и `robot_old_x`.

Затем вычисляется новое положение робота после предполагаемого хода, и оно сохраняется в `robot_new_y` и `robot_new_x`. Новые координаты легко получить, прибавив смещения, переданные аргументами, к старым координатам робота (оба аргумента задают вертикальное и горизонтальное смещение).

### Уперся ли робот в стену? {#did-the-robot-hit-a-wall}

```python
        if self.map[robot_new_y][robot_new_x] == 1:
            return
```

Условие выше обрабатывает ситуацию, когда робот упирается в стену. Напомним: число 1 соответствует стене в списке изображений. Такой ход запрещён, поэтому метод просто возвращается без изменений.

### Двигаем коробку {#moving-a-box}

```python
        if self.map[robot_new_y][robot_new_x] in [3, 5]:
            box_new_y = robot_new_y + move_y
            box_new_x = robot_new_x + move_x

            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
                return

            self.map[robot_new_y][robot_new_x] -= 3
            self.map[box_new_y][box_new_x] += 3
```

Если новая клетка робота содержит число 3 (коробка на обычной клетке) или 5 (коробка на клетке цели), робот пытается сдвинуть коробку дальше по направлению движения. Для этого нужны две новые переменные: `box_new_y` и `box_new_x`, которые хранят положение коробки после сдвига.

Как и робот, коробка не может быть передвинута в стену (значение 1). Также коробка не может встать на другую коробку или на клетку цели, где уже стоит коробка. Если из‑за хода возникла бы такая ситуация, метод снова просто возвращается, ничего не меняя.

Во всех остальных случаях коробку можно сдвинуть. Значение в клетке, где коробка стояла, уменьшается на 3, а значение в новой клетке увеличивается на 3. Благодаря продуманной нумерации в списке `images` это корректно работает и для обычных клеток пола, и для клеток цели.

### Двигаем робота {#moving-the-robot}

```python
        self.map[robot_old_y][robot_old_x] -= 4
        self.map[robot_new_y][robot_new_x] += 4
```

Если выполнение дошло до этого места без `return`, пора двигать и самого робота. Процедура похожа на перемещение коробки, но теперь мы вычитаем и прибавляем 4. Опять же, благодаря нумерации в `images` результат получается корректным и для обычных клеток, и для клеток цели.

## Рефакторинг? {#refactoring}

Хранить состояние игры только в сетке удобно: по сути мы постоянно работаем лишь с одной структурой данных, а обновлять состояние можно простыми прибавлениями и вычитаниями.

Минус в том, что код игры становится труднее понимать. Если человек не знаком с выбранной логикой, он, вероятно, удивится, увидев такую строку:

```python
            if self.map[box_new_y][box_new_x] in [1, 3, 5]:
```

Фрагмент выше использует _магические числа_ для обозначения типов клеток. Читателю нужно заранее знать, что 1 — это стена, 3 — коробка, а 5 — коробка на клетке цели.

Строки с вычитанием и прибавлением выглядят ещё загадочнее:

```python
            self.map[robot_new_y][robot_new_x] -= 3
```

Число 3 только что означало коробку, а теперь оно вычитается из значения клетки. Это работает в рамках нашей схемы нумерации: коробка (3) превращается в обычный пол (0), а «коробка на цели» (5) — в пустую цель (2). Но чтобы это понимать, нужно заранее знать правила нумерации.

Мы могли бы сделать код понятнее с помощью _рефакторинга_, то есть улучшить структуру и читаемость. Например, можно использовать имена типов клеток вместо чисел от 0 до 6 — хотя это всё равно не объяснит, почему прибавления и вычитания сохраняют корректное состояние сетки.

Чтобы сделать код действительно «прозрачным», скорее всего, нужен более глубокий рефакторинг. Например, можно хранить карту уровня отдельно, а координаты робота и коробок — в отдельной структуре данных. Минус _такого_ решения в том, что кода станет заметно больше, а внутренняя структура игры усложнится.

Тема рефакторинга и качества кода подробнее рассматривается в последующих курсах — например, _Software Development Methods_ и _Software Engineering_.
