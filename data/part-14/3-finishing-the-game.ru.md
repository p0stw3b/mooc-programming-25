---
path: /ru/part-14/3-finishing-the-game
title: Завершение игры
hidden: false
---

Наша игра уже вполне работоспособна, поэтому пора добавить финальные штрихи. Мы добавим счётчик ходов, возможность начать новую игру и выйти из игры с клавиатуры, а также сообщение о том, что игрок успешно прошёл уровень.

## Счётчик ходов {#move-counter}

Счётчик ходов в нижней части окна показывает, сколько ходов уже сделал игрок. По нему можно пытаться найти решение с минимальным количеством ходов.

Для счётчика нужно немного изменить код. Сначала изменим конструктор так, чтобы было место для текста, и подготовим подходящий шрифт для отрисовки:

```python
    def __init__(self):
        ...
        self.window = pygame.display.set_mode((window_width, window_height + self.scale))

        self.game_font = pygame.font.SysFont("Arial", 24)
        ...
```

Счётчик ходов инициализируется нулём в начале игры. Каждый ход увеличивает его на единицу:

```python
    def new_game(self):
        ...
        self.moves = 0
```

```python
    def move(self, move_y, move_x):
        ...
        self.moves += 1

```

Каждый раз при обновлении содержимого окна нужно обновлять и отображаемое число ходов:

```python
    def draw_window(self):
        ...
        game_text = self.game_font.render("Moves: " + str(self.moves), True, (255, 0, 0))
        self.window.blit(game_text, (25, self.height * self.scale + 10))
        ...
```

## Новая игра и выход {#new-game-and-exiting-the-game}

Далее добавим команды с клавиатуры: начать новую игру по F2 и выйти по Esc. Обе реализуются довольно просто:

```python
    def check_events(self):
        ...
                if event.key == pygame.K_F2:
                    self.new_game()
                if event.key == pygame.K_ESCAPE:
                    exit()
        ...
```

Также стоит показать игроку подсказки об этих командах:

```python
    def draw_window(self):
        ...
        game_text = self.game_font.render("F2 = new game", True, (255, 0, 0))
        self.window.blit(game_text, (200, self.height * self.scale + 10))

        game_text = self.game_font.render("Esc = exit game", True, (255, 0, 0))
        self.window.blit(game_text, (400, self.height * self.scale + 10))
        ...
```

## Прохождение игры {#solving-the-game}

Игрок проходит уровень, когда каждая коробка находится на одной из клеток цели. Следующий метод проверяет это:

```python
    def game_solved(self):
        for y in range(self.height):
            for x in range(self.width):
                if self.map[y][x] in [2, 6]:
                    return False
        return True
```

Метод проходит по всем клеткам поля. Если находится клетка со значением 2 (пустая клетка цели) или 6 (робот на клетке цели), значит игра ещё не решена, и метод возвращает `False`. Если таких клеток нет, значит все клетки цели заняты коробками, уровень пройден, и метод возвращает `True`.

Если игрок решает уровень, нужно вывести соответствующее сообщение в `draw_window`:

```python
    def draw_window(self):
        ...
        if self.game_solved():
            game_text = self.game_font.render("Congratulations, you solved the game!", True, (255, 0, 0))
            game_text_x = self.scale * self.width / 2 - game_text.get_width() / 2
            game_text_y = self.scale * self.height / 2 - game_text.get_height() / 2
            pygame.draw.rect(self.window, (0, 0, 0), (game_text_x, game_text_y, game_text.get_width(), game_text.get_height()))
            self.window.blit(game_text, (game_text_x, game_text_y))
        ...
```

Для полноты добавим также проверку в `move`, чтобы после прохождения игрок больше не мог двигаться:

```python
    def move(self, move_y, move_x):
        if self.game_solved():
            return
        ...
```

При этом игрок всё ещё видит поле и финальное состояние игры.

## Подсказка для тестирования {#a-hint-for-testing}

При разработке игр часто хочется проверить, что произойдёт в какой‑то «поздней» ситуации. В этой игре такой ситуацией является момент, когда уровень пройден.

Проверить корректность такой ситуации бывает сложно: обычно нужно реально пройти уровень, чтобы добраться до нужного момента. Как программисты мы можем делать временные «послабления», чтобы тестирование было проще. Например, можно временно добавить такое:

```python
    def game_solved(self):
        return True
```

Теперь метод всегда возвращает `True`, то есть игра считается «пройденной» сразу. Это позволяет легко проверить, что финальное уведомление выглядит нормально и что после прохождения игрок действительно больше не может двигаться. Когда всё протестировано, временные изменения можно отменить.

## Ваша игра на GitHub? {#your-game-on-github}

Игра готова. Если вы хотите удобный способ поэкспериментировать с кодом и изображениями, вы можете взять исходники с GitHub:

* [https://github.com/moocfi/sokoban](https://github.com/moocfi/sokoban)

GitHub — популярная платформа для самых разных программных проектов. Там можно хранить исходный код и материалы ваших собственных проектов, вести историю изменений через git и легко делиться кодом с другими. Если вы продолжите обучение на других курсах программирования mooc.fi, вы хорошо познакомитесь с git и GitHub.

## Сколько ходов нужно? {#how-many-moves-are-required}

Поле в этой игре довольно маленькое, но сама игра не так уж проста. Первый вызов — просто пройти уровень, а следующий этап — попытаться сделать это за минимальное число ходов. Каков самый короткий путь к решению?

Поиск кратчайшего решения — задача нетривиальная, но для неё существуют вычислительные методы. Это одна из тем курса _Data Structures and Algorithms_.
