---
path: /ru/part-11/3-recursion
title: Рекурсия
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, что такое рекурсия
- вы сможете написать простую рекурсивную функцию

</text-box>

Как мы уже много раз видели, функции могут вызывать другие функции. Например:

```python
def hello(name : str):
    print("Hello", name)

def hello_many_times(name : str, times : int):
    for i in range(times):
        hello(name)
```

Функция может вызывать и саму себя, но здесь нужно быть осторожным. Легко «провалиться» в бесконечную цепочку вызовов, так же как мы попадали в бесконечный цикл `while`, если забывали про условие остановки. Поэтому попытка вызвать функцию `hello` со следующим определением

```python
def hello(name : str):
    print("Hello", name)
    hello(name) # функция вызывает саму себя
```

приведёт к ошибке другого типа:

<sample-output>

RecursionError: maximum recursion depth exceeded

</sample-output>

## Что такое рекурсия? {#what-does-recursion-mean}

Слово _recursion_ в сообщении об ошибке означает «определение чего‑то через само себя». В программировании рекурсия обычно означает функцию, которая вызывает сама себя. Чтобы это работало и не приводило к бесконечному выполнению, аргументы при каждом вызове должны изменяться так, чтобы цепочка вложенных вызовов в какой‑то момент остановилась. Принцип тот же, что и у циклов `while`: должно быть условие остановки, и в ходе выполнения оно должно сработать.

Рассмотрим простую функцию, которая добавляет нули в список, пока в списке меньше 10 элементов. На этот раз мы не используем цикл. Если условие ещё не выполнено, функция вызывает саму себя:

```python
def fill_list(numbers: list):
    """Если длина списка меньше 10, добавляет элементы в список."""
    if len(numbers) < 10:
        numbers.append(0)
        # вызываем функцию снова
        fill_list(numbers)


if __name__ == "__main__":
    test_list = [1,2,3,4]
    fill_list(test_list)
    print(test_list)
```

<sample-output>

[1, 2, 3, 4, 0, 0, 0, 0, 0, 0]

</sample-output>

То же самое можно сделать и обычным циклом `while`:

```python
def fill_list(numbers: list):
    """Если длина списка меньше 10, добавляет элементы в список."""
    while len(numbers) < 10:
        numbers.append(0)

if __name__ == "__main__":
    test_list = [1,2,3,4]
    fill_list(test_list)
    print(test_list)
```

Более традиционный итеративный подход даёт более короткую программу, которую зачастую проще понять. В рекурсивной версии не так очевидно, что мы всё время работаем с одним и тем же списком. Но это так — именно поэтому рекурсивная функция работает не хуже.

<text-box variant="hint" name="Итеративно или рекурсивно?">

В теории информатики часто различают _итеративные_ и _рекурсивные_ алгоритмы, поэтому лучше познакомиться с этими терминами сразу. Итеративные решения основаны на последовательной обработке элементов — чаще всего с помощью циклов. До сих пор мы почти всегда использовали именно итеративные методы. Рекурсивный подход, напротив, означает метод, где функция вызывает саму себя, изменяя значения параметров.

В принципе любую задачу можно решить и итеративно, и рекурсивно. Но на практике обычно один из подходов заметно лучше подходит к конкретной задаче. Умение выбирать подход в основном приходит с практикой.

</text-box>

<programming-exercise name='Добавить числа в список' anchor="Add numbers to a list" tmcname='part11-13_add_numbers_to_list'>

Напишите _рекурсивную функцию_ `add_numbers_to_list(numbers: list)`. Функция принимает список чисел и добавляет новые числа в список, пока длина списка не станет делиться на 5. Каждое добавляемое число должно быть на 1 больше последнего числа в списке.

Функция обязательно должна вызывать саму себя (рекурсивно). Смотрите пример ниже.

```python
numbers = [1,3,4,5,10,11]
add_numbers_to_list(numbers)
print(numbers)
```

<sample-output>

[1, 3, 4, 5, 10, 11, 12, 13, 14, 15]

</sample-output>

</programming-exercise>

## Рекурсия и возвращаемые значения {#recursion-and-return-values}

Рекурсивные функции тоже могут возвращать значение. В последних разделах мы работали с факториалами, поэтому напишем рекурсивную функцию факториала:

```python

def factorial(n: int):
    """Функция вычисляет факториал n! для n >= 0."""
    if n < 2:
        # Факториал для 0 и 1 равен 1
        return 1

    # Вызываем функцию снова с аргументом, который на единицу меньше
    return n * factorial(n - 1)

if __name__ == "__main__":
    # Тестируем нашу функцию
    for i in range(1, 7):
        print(f"The factorial of {i} is {factorial(i)}")

```

<sample-output>

The factorial of 1 is 1
The factorial of 2 is 2
The factorial of 3 is 6
The factorial of 4 is 24
The factorial of 5 is 120
The factorial of 6 is 720

</sample-output>

Если параметр рекурсивной функции факториала равен 0 или 1, функция возвращает 1 — так определён факториал. В любом другом случае функция возвращает `n * factorial(n - 1)`: значение параметра `n`, умноженное на результат вызова `factorial(n - 1)`.

Ключевой момент: в определении функции есть условие остановки. Когда оно выполняется, рекурсия заканчивается. Здесь это условие `n < 2`. Мы знаем, что оно неизбежно достигнется, потому что на каждом уровне рекурсии аргумент уменьшается на 1.

[Инструмент визуализации](http://www.pythontutor.com/visualize.html#mode=edit) может сильно помочь в понимании рекурсивных программ.

Пример выше может стать понятнее, если использовать вспомогательные переменные:

```python
def factorial(n: int):
    if n < 2:
        return 1

    factorial_one_level_down = factorial(n - 1)
    factorial_now = n * factorial_one_level_down
    return factorial_now
    
factorial(5)
```

Посмотрите, как [инструмент визуализации](http://www.pythontutor.com/visualize.html#code=def%20factorial%28n%3A%20int%29%3A%0A%20%20%20%20if%20n%20%3C%202%3A%0A%20%20%20%20%20%20%20%20return%201%0A%0A%20%20%20%20factorial_one_level_down%20%3D%20factorial%28n%20-%201%29%0A%20%20%20%20factorial_now%20%3D%20n%20*%20factorial_one_level_down%0A%20%20%20%20return%20factorial_now%0A%20%20%20%20%0Afactorial%285%29&cumulative=false&curInstr=5&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false) показывает ход рекурсии.

У инструмента визуализации есть небольшая особенность: стек вызовов как будто «растёт вниз». Обычно стек изображают так, что новые вызовы находятся сверху. В инструменте визуализации активный вызов — это подсвеченный блок внизу, и у него видны свои копии переменных.

Когда вызывается рекурсивный факториал, стек вызовов растёт, пока не достигнется предел `n < 2`. Затем последний вызов в стеке возвращает значение `1` (так как `n` теперь меньше 2). Это значение передаётся предыдущему вызову, где используется для вычисления его результата, и так далее «разматывая» стек обратно.

Возвращаемое значение каждого вызова хранится во вспомогательной переменной `factorial_now`. Пройдитесь по визуализации внимательно, пока не поймёте, что происходит на каждом шаге, и обратите особое внимание на значения, которые возвращаются на каждом уровне.

<img src="11_1_1.png">

Рассмотрим ещё один распространённый пример рекурсии: числа Фибоначчи. В последовательности Фибоначчи каждое число равно сумме двух предыдущих. Первые два числа здесь определены как 1 и 1, а затем последовательность выглядит так: 1, 1, 2, 3, 5, 8, 13, 21, 34.

```python
def fibonacci(n: int):
    """Функция возвращает n-е число последовательности Фибоначчи (1, 1, 2, 3, 5, 8 и т. д.); n > 0."""

    if n <= 2:
        # первые два числа равны 1
        return 1

    # Все остальные числа равны сумме двух предыдущих
    return fibonacci(n - 1) + fibonacci(n - 2)

# Проверяем, что всё работает
if __name__ == "__main__":
    for i in range(1, 11):
        print(f"The {i}. number in the Fibonacci sequence is {fibonacci(i)}")
```

<sample-output>

The 1. number in the Fibonacci sequence is 1
The 2. number in the Fibonacci sequence is 1
The 3. number in the Fibonacci sequence is 2
The 4. number in the Fibonacci sequence is 3
The 5. number in the Fibonacci sequence is 5
The 6. number in the Fibonacci sequence is 8
The 7. number in the Fibonacci sequence is 13
The 8. number in the Fibonacci sequence is 21
The 9. number in the Fibonacci sequence is 34
The 10. number in the Fibonacci sequence is 55

</sample-output>

Здесь условие остановки — параметр меньше либо равен 2, потому что вся последовательность определяется от первых двух чисел, а первые два числа мы задали равными 1.

Как же эта функция работает на практике?

Если функция вызывается с аргументом 1 или 2, она возвращает 1 согласно условию `n <= 2`.

Если аргумент равен 3 или больше, функция возвращает `fibonacci(n - 1) + fibonacci(n - 2)`. Если аргумент ровно 3, это `fibonacci(2) + fibonacci(1)`, и результаты обоих вызовов мы уже знаем: `1 + 1` равно 2 — это действительно третье число в последовательности.

Если аргумент равен 4, возвращаемое значение — `fibonacci(3) + fibonacci(2)`, то есть `2 + 1`, что равно 3.

Если аргумент равен 5, возвращаемое значение — `fibonacci(4) + fibonacci(3)`, то есть `3 + 2`, что равно 5.

И так далее.

Мы можем на каждом шаге убедиться, что функция выдаёт правильные результаты — этого часто достаточно в базовых задачах программирования. Формальная проверяемость алгоритмов — тема более продвинутых курсов, например [Data Structures and Algorithms](https://studies.helsinki.fi/courses/cur/hy-opt-cur-2122-808d3413-3db0-4ab9-89d9-e816e94bf51d).

<programming-exercise name='Рекурсивная сумма' anchor="Recursive sum" tmcname='part11-14_recursive_sum'>

Напишите рекурсивную функцию `recursive_sum(number: int)`, которая вычисляет сумму `1 + 2 + ... + number`. В шаблоне упражнения есть такая заготовка:

```python
def recursive_sum(number: int):
    # если число равно 1, больше ничего складывать не нужно
    if number <= 1:
        return number

    # допишите остальную часть функции
```

Примеры:

```python
result = recursive_sum(3)
print(result)

print(recursive_sum(5))
print(recursive_sum(10))
```

<sample-output>

6
15
55

</sample-output>

</programming-exercise>

<programming-exercise name='Сбалансировать все скобки' anchor="Balance all the brackets" tmcname='part11-15_balanced_brackets'>

Шаблон упражнения содержит функцию `balanced_brackets`, которая принимает строку. Она проверяет, сбалансированы ли в строке _круглые_ скобки (parentheses). То есть для каждой открывающей скобки `(` должна быть закрывающая `)`, и пары скобок должны правильно соответствовать друг другу по порядку (пары не должны «перекрещиваться»).

```python
def balanced_brackets(my_string: str):
    if len(my_string) == 0:
        return True
    if not (my_string[0] == '(' and my_string[-1] == ')'):
        return False

    # удаляем первый и последний символ
    return balanced_brackets(my_string[1:-1])

ok = balanced_brackets("(((())))")
print(ok)

# здесь на одну закрывающую скобку больше, поэтому False
ok = balanced_brackets("()())")
print(ok)

# эта строка начинается с закрывающей скобки, снова False
ok = balanced_brackets(")()")
print(ok)

# здесь False, потому что функция обрабатывает только полностью вложенные скобки
ok = balanced_brackets("()(())")
print(ok)
```

<sample-output>

True
False
False
False

</sample-output>

Расширьте функцию так, чтобы она работала и с квадратными скобками `[]`. Функция также должна игнорировать любые символы, которые не являются скобками `()` или `[]`. Типы скобок должны корректно сопоставляться.

Посмотрите на примеры ниже:

```python
ok = balanced_brackets("([([])])")
print(ok)

ok = balanced_brackets("(python version [3.7]) please use this one!")
print(ok)

# это плохо: закрывающая скобка не совпадает
ok = balanced_brackets("(()]")
print(ok)

# разные типы скобок не совпадают
ok = balanced_brackets("([bad egg)]")
print(ok)
```

Важно: функция должна обрабатывать только полностью вложенные скобки. Строка `(x + 1)(y + 1)` должна давать `False`, потому что скобки не вложены друг в друга.

<sample-output>

True
True
False
False


</sample-output>

</programming-exercise>

## Двоичный поиск {#binary-search}

При двоичном поиске у нас есть отсортированный список элементов, и мы пытаемся найти в нём некоторый элемент. Порядок может быть, например, по возрастанию чисел или по алфавиту для строк. Способ сортировки не важен — важно только, что он известен и соответствует элементу, который мы ищем.

Идея двоичного поиска — каждый раз смотреть на элемент в самом центре списка. Затем возможны три сценария. Если центральный элемент:
- это то, что мы ищем — можно вернуть признак, что элемент найден
- меньше искомого — нужно продолжить поиск в правой (большей) половине списка
- больше искомого — нужно продолжить поиск в левой (меньшей) половине списка

Если список пуст, значит элемент не найден — возвращаем соответствующий результат.

На следующем рисунке видно, как двоичный поиск работает при поиске числа 24:

<img src="11_3_1.png">

Вот рекурсивный алгоритм двоичного поиска:

```python
def binary_search(target: list, item: int, left : int, right : int):
    """Функция возвращает True, если элемент содержится в списке target, иначе False."""
    # Если область поиска пуста, элемент не найден
    if left > right:
        return False

    # Находим середину области поиска (целочисленный результат)
    centre = (left+right)//2

    # Если элемент найден в середине, возвращаем результат
    if target[centre] == item:
        return True

    # Если искомый элемент больше, ищем в правой (большей) половине
    if target[centre] < item:
        return binary_search(target, item, centre+1, right)
    # Иначе искомый элемент меньше, ищем в левой (меньшей) половине
    else:
        return binary_search(target, item, left, centre-1)


if __name__ == "__main__":
    # Тестируем функцию
    target = [1, 2, 4, 5, 7, 8, 11, 13, 14, 18]
    print(binary_search(target, 2, 0, len(target)-1))
    print(binary_search(target, 13, 0, len(target)-1))
    print(binary_search(target, 6, 0, len(target)-1))
    print(binary_search(target, 15, 0, len(target)-1))
```

<sample-output>

True
True
False
False

</sample-output>

Функция `binary_search` принимает четыре аргумента: целевой список, искомый элемент и левую/правую границы области поиска. При первом вызове область поиска охватывает весь список: левая граница — индекс `0`, правая — `len(target)-1`. Функция вычисляет центральный индекс и проверяет элемент в этой позиции. Либо элемент найден, либо поиск продолжается в меньшей или большей половине списка.

Сравним это с линейным поиском. При линейном поиске мы просматриваем элементы по порядку, начиная с первого, пока либо не найдём нужный элемент, либо не закончатся элементы. Число шагов, необходимых для просмотра всей области поиска, растёт _линейно_ вместе с размером области поиска: каждый шаг проверяет только один кандидат. Предположим, что искомого элемента _нет_. Если область поиска содержит миллион элементов, потребуется миллион шагов, чтобы убедиться, что элемента там нет.

Двоичный поиск, напротив, требует число шагов, растущее _логарифмически_. Снова предположим, что искомого элемента _нет_. На каждом шаге область поиска делится пополам, потому что мы знаем, что искомый элемент либо меньше, либо больше текущего центрального кандидата. 2 в степени 20 (2^20) — это уже существенно больше миллиона, поэтому двоичный поиск покрывает область длиной около миллиона максимум за 20 шагов. Поэтому, когда мы работаем с отсортированными данными (что часто бывает в автоматической обработке), двоичный поиск гораздо эффективнее линейного.
