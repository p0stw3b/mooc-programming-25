---
path: /ru/part-11/1-list-comprehensions
title: Списковые включения
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете знать, что такое списковые включения (list comprehensions)
- вы сможете использовать списковые включения для создания новых списков

</text-box>

Одна из ситуаций, в которых программирование проявляет свою силу, — обработка последовательностей элементов и событий. Компьютеры отлично подходят для повторяющихся действий. Например, в предыдущих частях материалов мы разными способами проходили по строкам, спискам и словарям.

Предположим, у нас есть список целых чисел и нам нужен такой же список, но в виде строк. Традиционный способ мог бы выглядеть так:

```python
numbers = [1, 2, 3, 6, 5, 4, 7]

strings = []
for number in numbers:
    strings.append(str(number))
```

## Списковые включения {#list-comprehensions}

Есть и более «питоничный» способ создавать списки на основе других списков. Он называется _списковыми включениями_ (list comprehensions).

Идея в том, чтобы в одной строке описать, что нужно сделать с каждым элементом исходного списка, и сразу присвоить результат новому списку.

В примере выше операция была простой: каждое число преобразовывалось в строку. Посмотрим, как это выглядит со списковым включением:

```python
numbers = [1, 2, 3, 6, 5, 4, 7]
strings = [str(number) for number in numbers]
```

Во второй строке есть те же элементы, что и в традиционном цикле, но синтаксис другой. Обобщённая форма спискового включения выглядит так:

`[<expression> for <item> in <series>]`

Квадратные скобки вокруг выражения сообщают Python, что результатом должен быть новый список. Элементы исходного списка обрабатываются по одному, и результаты складываются в новый список — точно так же, как в цикле. В итоге получается новый список той же длины, где каждый элемент обработан одинаковым образом.

(Важно: оригиналы изображений в этой части временно отсутствуют, поэтому на иллюстрациях встречается финская лексика. Мы работаем над тем, чтобы это исправить.)

<img src="11_1_2.png">

Списковые включения умеют и более сложные операции. Например, можно выполнять вычисления — умножим исходные элементы на десять:

```python
numbers = list(range(1,10))
print(numbers)

numbers_multiplied = [number * 10 for number in numbers]
print(numbers_multiplied)
```

<sample-output>

[1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 20, 30, 40, 50, 60, 70, 80, 90]

</sample-output>

На самом деле выражение внутри спискового включения может быть любым выражением Python. Можно даже вызывать функции, которые вы определили сами:

```python
def factorial(n: int):
    """Функция вычисляет факториал n! для целых чисел больше нуля."""
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [5, 2, 4, 3, 0]
    factorials = [factorial(number) for number in numbers]
    print(factorials)
```

<sample-output>

[120, 2, 24, 6, 1]

</sample-output>

То же самое с «обычным» циклом `for` выглядело бы так:

```python
def factorial(n: int):
    """Функция вычисляет факториал n! для целых чисел больше нуля."""
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [5, 2, 4, 3, 0]
    factorials = []
    for number in numbers:
        factorials.append(factorial(number))
    print(factorials)
```

Списковые включения позволяют выразить ту же функциональность более компактно и обычно без потери читаемости.

Можно также напрямую возвращать списковое включение из функции. Если нам нужна функция, которая возвращает факториалы для списка чисел, это делается очень кратко:

```python
def factorials(numbers: list):
    return [factorial(number) for number in numbers]
```

<programming-exercise name='Квадратные корни' anchor="Square roots" tmcname='part11-01_square_roots'>

Напишите функцию `square_roots(numbers: list)`, которая принимает список целых чисел. Функция должна вернуть новый список, содержащий квадратные корни исходных чисел.

В стандартной библиотеке Python есть модуль [math](https://docs.python.org/3/library/math.html) с подходящей функцией для вычисления квадратного корня.

Функция должна использовать списковое включение. Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Функция должна работать так:

```python
lines = square_roots([1,2,3,4])
for line in lines:
    print(line)
```

<sample-output>

1.0
1.4142135623730951
1.7320508075688772
2.0

</sample-output>

</programming-exercise>

<programming-exercise name='Ряды звёздочек' anchor="Rows of stars" tmcname='part11-02_rows_of_stars'>

Напишите функцию `rows_of_stars(numbers: list)`, которая принимает список целых чисел. Функция должна вернуть новый список строк со звёздочками. Длина каждой строки должна соответствовать числу с тем же индексом в исходном списке. Используйте списковое включение.

Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Функция должна работать так:

```python
rows = rows_of_stars([1,2,3,4])
for row in rows:
    print(row)

print()

rows = rows_of_stars([4, 3, 2, 1, 10])
for row in rows:
    print(row)
```

<sample-output>

<pre>
*
**
***
****

****
***
**
*
**********
</pre>

</sample-output>

</programming-exercise>

<programming-exercise name='Лучший результат экзамена' anchor="Best exam result" tmcname='part11-03_best_exam_result'>

Шаблон упражнения содержит определение класса `ExamResult`. У класса есть следующие публичные атрибуты:

* name
* grade1
* grade2
* grade3

Напишите функцию `best_results(results: list)`, которая принимает список объектов `ExamResult`.

Функция должна вернуть новый список, содержащий только лучший результат для каждого объекта `ExamResult`. Реализуйте это с помощью спискового включения.

Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Функция должна работать так:

```python
result1 = ExamResult("Peter",5,3,4)
result2 = ExamResult("Pippa",3,4,1)
result3 = ExamResult("Paul",2,1,3)
results = [result1, result2, result3]
print(best_results(results))
```

<sample-output>

[5, 4, 3]

</sample-output>

</programming-exercise>

<programming-exercise name='Длины' anchor="Lengths" tmcname='part11-04_lengths'>

Напишите функцию `lengths(lists: list)`, которая принимает список, содержащий списки целых чисел. Функция должна вернуть новый список, содержащий длины внутренних списков.

Используйте списковое включение. Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Функция должна работать так:

```python
lists = [[1,2,3,4,5], [324, -1, 31, 7],[]]
print(lengths(lists))
```

<sample-output>

[5, 4, 0]

</sample-output>

</programming-exercise>

## Фильтрация элементов {#filtering-items}

В примерах выше длина списка до и после выполнения спискового включения оставалась одинаковой: в каждом случае все элементы исходного списка использовались для построения нового. Но иногда нам нужны только _некоторые_ элементы исходного списка. Как это сделать?

Списковое включение может содержать условие: мы проверяем элементы и выбираем только те, которые удовлетворяют условию. Общий синтаксис такой:

`[<expression> for <item> in <series> if <Boolean expression>]`

В остальном выражение совпадает с общей формой из начала раздела, но теперь в конце есть `if`. В новый список попадут только те элементы исходного списка, для которых булево выражение истинно.

В примере ниже мы выбираем все чётные элементы исходного списка. Более того, мы никак их дополнительно не обрабатываем: они попадают в новый список как есть:

```python
numbers = [1, 1, 2, 3, 4, 6, 4, 5, 7, 10, 12, 3]

even_items = [item for item in numbers if item % 2 == 0]
print(even_items)
```

<sample-output>

[2, 4, 6, 4, 10, 12]

</sample-output>

Выражение в списковом включении выше — это просто `item`, то есть над элементами не выполняется никаких операций. Как и в предыдущих примерах, выражением может быть любое выражение Python. Например, следующее включение берёт все чётные элементы, умножает каждый на 10 и сохраняет результат в новый список:

```python
numbers = [1, 1, 2, 3, 4, 6, 4, 5, 7, 10, 12, 3]

even_items = [item * 10 for item in numbers if item % 2 == 0]
print(even_items)
```

<sample-output>

[20, 40, 60, 40, 100, 120]

</sample-output>

Когда списковые включения становятся более сложными, бывает полезно сначала читать условие. В конце концов, элементы обрабатываются только если проходят проверку, поэтому часто разумно сперва понять, какие элементы останутся после фильтрации. Иногда выражение в списковом включении вообще не определено для всех элементов исходного списка.

Например, факториал определён только для неотрицательных целых чисел. Если мы не уверены, что список содержит только значения не меньше нуля, содержимое нужно отфильтровать перед тем, как передавать элементы в функцию факториала:

```python
def factorial(n: int):
    """Функция вычисляет факториал n! для целых чисел больше нуля."""
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [-2, 3, -1, 4, -10, 5, 1]
    factorials = [factorial(number) for number in numbers if number >= 0]
    print(factorials)
```

<sample-output>

[6, 24, 120, 1]

</sample-output>

Как мы видели в самом первом примере, где числа преобразовывались в строки, элементы нового списка не обязаны иметь тот же тип, что и элементы исходного. Продолжая пример с факториалом, мы можем для каждого элемента создать кортеж из исходного числа и результата обработки и сохранить эти кортежи в список, объединив всё изученное в одном выражении:

```python
def factorial(n: int):
    """Функция вычисляет факториал n! для целых чисел больше нуля."""
    k = 1
    while n >= 2:
        k *= n
        n -= 1
    return k

if __name__ == "__main__":
    numbers = [-2, 3, 2, 1, 4, -10, 5, 1, 6]
    # имя переменной сокращено для удобства чтения
    factorials = [(n, factorial(n)) for n in numbers if n > 0 and n % 2 == 0]
    print(factorials)
```

<sample-output>

[(2, 2), (4, 24), (6, 720)]

</sample-output>

Если разобрать пример выше, то в нём есть булево выражение `n > 0 and n % 2 == 0`. Это значит, что для дальнейшей обработки выбираются только те элементы исходного списка, которые одновременно положительные и делятся на два.

Затем эти положительные чётные числа по очереди преобразуются в формат `(n, factorial(n))`. Это кортеж, где первый элемент — само число, а второй — результат функции факториала.

<programming-exercise name='Удалить меньше, чем' anchor="Remove smaller than" tmcname='part11-05_remove_smaller_than'>

Напишите функцию `remove_smaller_than(numbers: list, limit: int)`, которая принимает список целых чисел и пороговое значение (тоже целое число).

Функция должна с помощью спискового включения создать новый список без значений, меньших `limit`.

Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Пример использования:

```python
numbers = [1,65, 32, -6, 9, 11]
print(remove_smaller_than(numbers, 10))

print(remove_smaller_than([-4, 7, 8, -100], 0))
```

<sample-output>

[65, 32, 11]
[7, 8]

</sample-output>

</programming-exercise>

<programming-exercise name='Начинаются с гласной' anchor="Begin with a vowel" tmcname='part11-06_begin_with_vowel'>

Напишите функцию `begin_with_vowel(words: list)`, которая принимает список строк.

Функция должна с помощью спискового включения создать и вернуть новый список, содержащий только те слова, которые начинаются с гласной (a, e, i, o, u). Должны приниматься и строчные, и заглавные буквы.

Максимальная длина функции — две строки кода, включая строку заголовка, начинающуюся с `def`.

Пример использования:

```python
word_list = ["automobile","motorbike","Animal","cat","Dog","APPLE","orange"]
for vowelled in begin_with_vowel(word_list):
    print(vowelled)
```

<sample-output>

automobile
Animal
APPLE
orange

</sample-output>

</programming-exercise>

## Альтернативное выражение в списковых включениях {#alternative-execution-with-list-comprehensions}

Часто условная конструкция содержит ветку `else`. Так как в списковых включениях можно использовать условия, то в них также доступна и ветка `else`. Общий синтаксис условного выражения такой:

`<expression 1> if <condition> else <expression 2>`

С однострочным условием (тернарным оператором) мы уже встречались в [части 7](/ru/part-7/6-more-features). Выражение выше вычисляется либо в `expression 1`, либо в `expression 2` в зависимости от того, истинно условие или ложно.

Чтобы освежить в памяти, если нам нужно вывести большее из двух чисел и мы хотим обойтись одной командой `print`, это можно записать в одну строку:

```python
number1 = int(input("Type in number 1:"))
number2 = int(input("Type in number 2:"))
print (number1 if number1 > number2 else number2)
```

Если объединить тернарный оператор со списковым включением, получится такая общая структура:

`[<expression 1> if <condition> else <expression 2> for <item> in <series>]`

Это может выглядеть немного запутанно, потому что условная конструкция теперь стоит перед частью `for ... in ...`. Так определён синтаксис (по крайней мере сейчас): если есть `else`, условие пишется первым; если есть только `if`, он идёт в конце. Можете попробовать поменять местами и посмотреть, что получится.

Наличие `else` означает, что мы снова обрабатываем каждый элемент исходного списка. В зависимости от истинности условия к каждому элементу применяется либо `expression 1`, либо `expression 2`.

Следующий пример проверяет, неотрицателен ли элемент. Если да — элемент остаётся как есть, если нет — берётся отрицание, чтобы получить положительное значение. В результате получается список абсолютных значений исходных элементов.

```python
numbers = [1, -3, 45, -110, 2, 9, -11]
abs_vals = [number if number >= 0 else -number for number in numbers]
print(abs_vals)
```

<sample-output>

[1, 3, 45, 110, 2, 9, 11]

</sample-output>

Повторим происходящее: если условие `number >= 0` истинно, применяется выражение `number`, то есть элемент остаётся неизменным. Если условие ложно, применяется `-number`, и значение становится положительным.

В следующем примере функция `string_lengths` принимает список и возвращает другой список: длины строк из исходного списка. При этом функция готова к элементам любого типа. Если элемент — строка, вычисляется её длина. Если элемент другого типа, в результат подставляется `-1`.

```python
def string_lengths(my_list: list):
    """Функция возвращает новый список с длинами строк."""
    return [len(item) if type(item) == str else -1 for item in my_list]

if __name__ == "__main__":
    test_list = ["hi", 3, True, "there", -123.344, "toodlepip", 2, False]
    lengths = string_lengths(test_list)
    print(lengths)
```

<sample-output>

[2, -1, -1, 5, -1, 9, -1, -1]

</sample-output>


<programming-exercise name='Лотерейные числа' anchor="Lottery numbers" tmcname='part11-07_lottery_numbers'>

## LotteryNumbers: количество совпадений {#lotterynumbers-matched}

Напишите класс `LotteryNumbers`, который принимает в конструкторе номер недели (целое число) и список из семи целых чисел. Список должен содержать правильные лотерейные числа для этой недели.

Также напишите метод `number_of_hits(numbers: list)`, который принимает список целых чисел и возвращает количество совпадений между переданными числами и правильными числами недели.

Метод должен использовать списковое включение. Максимальная длина — две строки кода, включая строку заголовка, начинающуюся с `def`.

Пример использования:

```python
week5 = LotteryNumbers(5, [1,2,3,4,5,6,7])
my_numbers = [1,4,7,11,13,19,24]

print(week5.number_of_hits(my_numbers))
```

<sample-output>

3

</sample-output>

## LotteryNumbers: совпадения по позициям {#lotterynumbers-matched-in-place}

Напишите метод `hits_in_place(numbers)`, который принимает список из семи целых чисел и возвращает новый список из семи целых чисел. Новый список должен содержать только те элементы исходного списка, которые совпадают с правильными числами недели, и они должны оставаться на тех же индексах. Остальные позиции нужно заполнить значением `-1`.

Метод должен использовать списковое включение. Максимальная длина — две строки кода, включая строку заголовка, начинающуюся с `def`.

Посмотрите на пример ниже:

```python
week8 = LotteryNumbers(8, [1,2,3,10,20,30,33])
my_numbers = [1,4,7,10,11,20,30]

print(week8.hits_in_place(my_numbers))
```

<sample-output>

[1, -1, -1, 10, -1, 20, 30]

</sample-output>

</programming-exercise>
