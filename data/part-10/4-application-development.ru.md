---
path: /ru/part-10/4-application-development
title: Разработка более крупного приложения
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы познакомитесь с базовыми принципами разработки приложений
- вы будете уверенно различать части приложения (пользовательский интерфейс, логика программы и работа с файлами)
- вы попрактикуетесь в написании собственного относительно большого приложения

</text-box>

К этому моменту в материалах курса мы уже рассмотрели множество возможностей Python.

Курс «Введение в программирование» познакомил нас с управляющими конструкциями (например, `while` и `for`), функциями и базовыми структурами данных (списки, кортежи и словари). В принципе, этих инструментов достаточно, чтобы выразить на Python любую задумку программиста.

В «Продвинутом курсе программирования», начиная с части 8, вы познакомились с классами и объектами. Давайте на минуту остановимся и подумаем, когда и _зачем_ они нужны, если инструментов из частей 1–7 вроде бы должно хватать.

## Управление сложностью {#managing-complexity}

Объекты и классы нужны далеко не всегда. Например, если вы пишете небольшой одноразовый скрипт, объекты обычно избыточны. Но когда программа становится больше и сложнее, объекты оказываются очень полезными.

По мере роста сложности количество деталей быстро становится неуправляемым, если программу не организовать системно. Даже некоторые из более сложных упражнений, которые встречались вам ранее на курсе, выиграли бы от подходов, показанных в этом разделе.

На протяжении десятилетий идея [разделения ответственности (separation of concerns)](https://en.wikipedia.org/wiki/Separation_of_concerns) остаётся одним из ключевых принципов программирования и информатики в целом. Цитата из Википедии:

_Разделение ответственности — это принцип проектирования, при котором компьютерную программу разделяют на отдельные части так, чтобы каждая часть отвечала за свою отдельную задачу. «Задача» (concern) — это набор информации, который влияет на код компьютерной программы._

Разделение программы на части, каждая из которых отвечает за свою задачу, помогает управлять неизбежной сложностью компьютерной программы.

Функции — один из способов организовать программу в отдельные управляемые части. Вместо одного большого скрипта идея состоит в том, чтобы сформулировать небольшие, по отдельности проверяемые функции, каждая из которых решает часть общей задачи.

Другой распространённый подход к управлению большими программами — использование объектов и принципов объектно‑ориентированного программирования. У обоих подходов (и у функций, и у объектов) есть свои плюсы и минусы, и у каждого программиста свои предпочтения. Как мы уже видели, объекты и классы позволяют собрать в одном месте и данные, и код, который эти данные обрабатывает — в атрибутах и методах объекта. Кроме того, объекты позволяют инкапсулировать данные, которыми они управляют, чтобы другим частям программы не приходилось думать о внутренних деталях.

## Разбор примера: телефонная книга {#a-worked-example-phone-book}

Как разделить программу на классы и объекты? Это вовсе не простой вопрос с единственным правильным ответом, поэтому мы пойдём от примера. В части 5 вы выполняли [приложение «телефонная книга»](/ru/part-5/3-dictionary#programming-exercise-phone-book-version-2), а теперь реализуем нечто похожее с использованием принципов ООП.

Следуя принципу разделения ответственности, программу стоит разбивать на части, каждая из которых отвечает за свою задачу. В объектно‑ориентированном программировании это выражается через [принцип единственной ответственности (single-responsibility principle)](https://en.wikipedia.org/wiki/Single-responsibility_principle). Не вдаваясь в тонкости, смысл ясен из названия: _один класс и объекты, созданные на его основе, должны иметь одну ответственность в программе_.

ООП часто используют как способ моделировать объекты и явления реального мира. Один объект реального мира представляют одним классом в коде. В случае телефонной книги такими объектами могут быть:
- человек
- имя
- номер телефона

Имя и номер телефона можно рассматривать как «просто данные», которые не обязательно оформлять отдельными классами, а вот _человек_ — это отдельная сущность, и в программном мире её удобно представить классом. Объект `Person` мог бы отвечать за связь между именем и телефонными номерами, которые к нему относятся.

Сама _телефонная книга_ также хорошо подходит на роль класса. Её ответственность — управлять объектами людей и данными, которые они содержат.

Итак, мы наметили ядро нашего приложения: _телефонная книга_ и _человек_ составляют программную логику приложения (часто её называют _логикой приложения_). Но нашему приложению нужны и другие классы.

Обычно взаимодействие с пользователем стоит держать отдельно от логики приложения: это самостоятельная ответственность. Поэтому, помимо основной логики, в программе должен быть класс, который отвечает за пользовательский интерфейс.

Кроме того, телефонной книге нужно как‑то сохранять данные между запусками. Работа с файлами — снова отдельная ответственность, поэтому ей также нужен свой класс.

Теперь, когда мы наметили основные компоненты программы, возникает вопрос: с чего начинать? Единственно правильного ответа нет, но часто удобно начать с части логики приложения.

## Шаг 1: каркас логики приложения {#step-1-an-outline-for-the-application-logic}

Начнём с класса _PhoneBook_. Примерный каркас может выглядеть так:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = []

    def add_number(self, name: str, number: str):
        pass

    def get_numbers(self, name: str):
        pass

```

Класс содержит коллекцию людей и методы для добавления и получения данных.

У каждого человека может быть несколько номеров, поэтому внутреннюю структуру `persons` удобно реализовать словарём. В словаре можно искать по ключу‑имени, а значением при этом может быть список. Пока что кажется, что отдельный класс для человека не нужен — достаточно записи в словаре.

Реализуем перечисленные методы и протестируем телефонную книгу:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = {}

    def add_number(self, name: str, number: str):
        if not name in self.__persons:
            # добавляем новую запись в словарь с пустым списком номеров
            self.__persons[name] = []

        self.__persons[name].append(number)

    def get_numbers(self, name: str):
        if not name in self.__persons:
            return None

        return self.__persons[name]

# код для тестирования
phonebook = PhoneBook()
phonebook.add_number("Eric", "02-123456")
print(phonebook.get_numbers("Eric"))
print(phonebook.get_numbers("Emily"))
```

Это должно вывести:

<sample-output>

['02-123456']
None

</sample-output>

Метод `get_numbers` возвращает `None`, если имени нет в телефонной книге. Если имя найдено, он возвращает список номеров, связанных с этим именем.

Когда вы вносите изменения в программу, _всегда_ стоит проверить, что код работает как ожидалось, прежде чем переходить к следующим изменениям. Код, который вы пишете для тестирования, обычно быстро удаляется, поэтому может казаться, что писать такие проверки «не стоит усилий». В большинстве случаев это не так. Тестирование — важная часть хорошего результата в программировании.

Ошибку в программе нужно обнаруживать и исправлять как можно раньше. Если вы привыкнете проверять работоспособность почти после каждой новой строки кода, то ошибки обычно будут находиться быстро: вы почти наверняка знаете, что проблема появилась из‑за последнего изменения. Если же тестировать программу только после десятков добавленных строк, число возможных источников ошибки увеличится во много раз.

## Шаг 2: каркас пользовательского интерфейса {#step-2-an-outline-for-the-user-interface}

После того как основная логика приложения готова, пора реализовать текстовый пользовательский интерфейс. Нам понадобится новый класс `PhoneBookApplication` со следующей начальной функциональностью:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break

application = PhoneBookApplication()
application.execute()
```

Пока программа делает немного, но разберём её. Конструктор создаёт новый `PhoneBook`, который хранится в приватном атрибуте. Метод `execute(self)` запускает текстовый интерфейс; его основа — цикл `while`, который запрашивает команды пользователя, пока тот не введёт команду выхода. Есть также метод с инструкциями `help(self)`, который вызывается до входа в цикл, чтобы вывести подсказки.

Теперь добавим реальную функциональность. Сначала реализуем добавление новых данных в телефонную книгу:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                name = input("name: ")
                number = input("number: ")
                self.__phonebook.add_number(name, number)

application = PhoneBookApplication()
application.execute()
```

Если пользователь вводит _1_ для добавления нового номера, интерфейс запрашивает имя и номер и добавляет их в `PhoneBook` с помощью соответствующего метода.

Единственная ответственность пользовательского интерфейса — общаться с пользователем. Любая другая функциональность (например, хранение пары имя‑номер) — ответственность объекта `PhoneBook`.

Структуру нашего класса интерфейса можно улучшить. Создадим метод `add_entry(self)`, который будет обрабатывать команду добавления записи:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")

    # разделение ответственности: отдельный метод для добавления записи
    def add_entry(self):
        name = input("name: ")
        number = input("number: ")
        self.__phonebook.add_number(name, number)

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                self.add_entry()

application = PhoneBookApplication()
application.execute()
```

Принцип _разделения ответственности_ распространяется и на уровень методов. Можно было бы реализовать весь интерфейс в одном большом и сложном цикле `while`, но лучше выделить каждую функцию в отдельный метод. Ответственность метода `execute()` — лишь делегировать команды пользователя соответствующим методам. Это помогает управлять растущей сложностью программы. Например, если позже мы захотим изменить процесс добавления записей, сразу понятно, что работать нужно в `add_entry()`.

Добавим в интерфейс возможность поиска записей. Для этого тоже выделим отдельный метод:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()

    def help(self):
        print("commands: ")
        print("0 exit")
        print("1 add entry")
        print("2 search")

    def add_entry(self):
        name = input("name: ")
        number = input("number: ")
        self.__phonebook.add_number(name, number)

    def search(self):
        name = input("name: ")
        numbers = self.__phonebook.get_numbers(name)
        if numbers == None:
            print("number unknown")
            return
        for number in numbers:
            print(number)

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":
                break
            elif command == "1":
                self.add_entry()
            elif command == "2":
                self.search()
            else:
                self.help()

application = PhoneBookApplication()
application.execute()
```

Теперь у нас есть простое работающее приложение «телефонная книга», готовое к проверке. Ниже пример запуска:

<sample-output>

commands:
0 exit
1 add entry
2 search

command: **1**
name: **Eric**
number: **02-123456**

command: **1**
name: **Eric**
number: **045-4356713**

command: **2**
name: **Eric**
02-123456
045-4356713

command: **2**
name: Emily
number unknown

command: **0**

</sample-output>

Для такого простого приложения мы написали довольно много кода. Если бы мы сделали всё внутри одного цикла `while`, вероятно, можно было бы обойтись меньшим количеством строк. Однако код сейчас легко читать, структура понятна, и нам будет несложно добавлять новые возможности.

## Шаг 3: импорт данных из файла {#step-3-importing-data-from-a-file}

Предположим, что некоторые номера уже сохранены в файле, и мы хотим загрузить их при запуске программы. Файл данных имеет следующий формат CSV:

```csv
Eric;02-1234567;045-4356713
Emily;040-324344
```

Работа с файлами — явно отдельная ответственность, поэтому для неё нужен свой класс:

```python
class FileHandler:
    def __init__(self, filename):
        self.__filename = filename

    def load_file(self):
        names = {}
        with open(self.__filename) as f:
            for line in f:
                parts = line.strip().split(';')
                name, *numbers = parts
                names[name] = numbers

        return names
```

Конструктор принимает имя файла. Метод `load_file(self)` читает содержимое файла, разбивает каждую строку на две части: имя и список номеров. Затем добавляет их в словарь, используя имя как ключ, а список — как значение.

Метод использует удобную возможность Python: можно отдельно извлечь первые элементы списка, а остальные собрать в новый список. Пример ниже. Вы можете помнить из [части 6](/ru/part-6/1-reading-files#reading-csv-files), что строковый метод `split` возвращает список.

```python
my_list = [1, 2, 3, 4, 5]
first, second, *rest = my_list
print(first)
print(second)
print(rest)
```

<sample-output>

1
2
[3, 4, 5]

</sample-output>

`*` перед именем переменной `rest` в присваивании означает, что эта последняя переменная должна содержать все оставшиеся элементы списка, начиная с третьего.

Прежде чем подключать обработчик файлов к приложению, обязательно протестируйте его отдельно:

```python
t = FileHandler("phonebook.txt")
print(t.load_file())
```

<sample-output>

{'Eric': ['02-1234567', '045-4356713'], 'Emily': ['040-324344']}

</sample-output>

Раз обработчик файлов работает, можно добавить его в приложение. Предположим, что мы хотим читать файл при каждом запуске программы. Логичное место для этого — конструктор класса `PhoneBookApplication`:

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()
        self.__filehandler = FileHandler("phonebook.txt")

        # добавляем имена и номера из файла в телефонную книгу
        for name, numbers in self.__filehandler.load_file().items():
            for number in numbers:
                self.__phonebook.add_number(name, number)

    # ...остальная часть программы
```

Эту функциональность тоже стоит проверить. Убедившись, что содержимое файла доступно через пользовательский интерфейс, можно переходить к следующему этапу.

## Шаг 4: экспорт данных в файл {#step-4-export-data-to-a-file}

Последняя возможность в базовой версии приложения — сохранение содержимого телефонной книги обратно в тот же файл, из которого данные были прочитаны.

Для этого потребуется изменить класс `PhoneBook`. Нам нужно уметь «выгружать» содержимое телефонной книги:

```python
class PhoneBook:
    def __init__(self):
        self.__persons = {}

    # ...

    # вернуть все записи (в формате словаря)
    def all_entries(self):
        return self.__persons
```

Непосредственное сохранение в файл должно выполняться классом `FileHandler`. Добавим метод `save_file`, который принимает телефонную книгу в виде словаря:

```python
class FileHandler():
    def __init__(self, filename):
        self.__filename = filename

    def load_file(self):
        # ...

    def save_file(self, phonebook: dict):
        with open(self.__filename, "w") as f:
            for name, numbers in phonebook.items():
                line = [name] + numbers
                f.write(";".join(line) + "\n")
```

Сохранение должно происходить при выходе из программы. Добавим метод для этого в класс интерфейса и вызовем его перед выходом из цикла `while`:

```python

class PhoneBookApplication:
    # ...остальной код пользовательского интерфейса

    # метод, который выполняется при выходе из программы
    def exit(self):
        self.__filehandler.save_file(self.__phonebook.all_entries())

    def execute(self):
        self.help()
        while True:
            print("")
            command = input("command: ")
            if command == "0":

                self.exit()
                break
            elif command == "1":
                self.add_entry()
            elif command == "2":
                self.search()
            else:
                self.help()
```

<programming-exercise name='Расширение телефонной книги, версия 1' anchor="Phone book expansion, version 1" tmcname='part10-10_phone_book_v1'>

В этом упражнении вы добавите небольшое расширение к приложению «телефонная книга». Код из примера выше уже есть в шаблоне. Добавьте команду, которая позволит пользователю искать в телефонной книге по номеру. После добавления приложение должно работать так:

<sample-output>

commands:
0 exit
1 add entry
2 search
3 search by number

command: **1**
name: **Eric**
number: **02-123456**

command: **1**
name: **Eric**
number: **045-4356713**

command: **3**
number: **02-123456**
Eric

command: **3**
number: **0100100**
unknown number

command: **0**

</sample-output>

Реализуйте это расширение с учётом текущей структуры программы. Это означает, что в классе `PhoneBookApplication` нужно добавить вспомогательный метод для новой функциональности и добавить новую ветку в цикл `while`. В классе `PhoneBook` добавьте метод, который позволяет искать по номеру.

**Важно:** пока вы тестируете программу, в файл `phonebook.txt` может накопиться много разных номеров. Из‑за этого локальные тесты иногда могут не пройти, если при запуске приложения из файла прочитаются «конфликтующие» данные. Перед запуском локальных тестов попробуйте очистить содержимое всех файлов `phonebook.txt`, которые вы найдёте в папке упражнения. Какой именно файл использует ваша программа, может зависеть от настроек Visual Studio Code. Посмотрите объяснение в [части 6](/ru/part-6/1-reading-files#what-if-visual-studio-code-cannot-find-my-file). Если решение корректное, тесты на сервере всё равно должны проходить.

</programming-exercise>

## Объекты в словаре {#objects-in-a-dictionary}

В следующем упражнении вам нужно изменить телефонную книгу так, чтобы значениями в словаре были _объекты_, а не списки.

В этом нет ничего «странного», но на этом курсе это впервые предлагается в таком виде, поэтому перед упражнением разберём более простой пример.

Здесь показан пример приложения, которое отслеживает, сколько упражнений выполнил каждый студент на курсе. Количество упражнений каждого студента хранится в простом объекте:

```python
class ExerciseCounter:
    def __init__(self):
        self.__exercises = 0

    def done(self):
        self.__exercises += 1

    def how_many(self):
        return self.__exercises
```

Следующая основная функция использует класс выше:

```python
students = {}

print("let's do some exercises")
while True:
    name = input("student: ")
    if len(name) == 0:
        break

    # создаём новый объект, если его ещё нет
    if not name in students:
        students[name] = ExerciseCounter()

    # отмечаем ещё одно выполненное упражнение
    students[name].done()

print()
print("exercises completed:")

for student, exercises in students.items():
    print(f"{student}'s exercises: {exercises.how_many()}")
```

Запуск может выглядеть так:

<sample-output>

let's do some exercises
student: **peter**
student: **sarah**
student: **andy**
student: **sarah**
student: **charlotte**
student: **charlotte**
student: **andy**
student: **sarah**
student:

exercises completed:
peter's exercises: 1
andy's exercises: 2
sarah's exercises: 3
charlotte's exercises: 2

</sample-output>

В примере выше есть несколько важных моментов. Когда пользователь вводит имя, программа сначала проверяет, есть ли оно среди ключей словаря. Если имени нет, создаётся новый объект и добавляется в словарь:

```python
if not name in students:
    students[name] = ExerciseCounter()
```

После этого мы можем быть _уверены_, что объект существует и «прикреплён» к имени студента (ключу словаря). Либо объект только что создали, либо он уже существовал с предыдущей итерации цикла. В любом случае теперь можно получить объект по ключу и вызвать метод `done`:

```python
students[name].done()
```

В строке выше на самом деле два шага. Можно использовать вспомогательную переменную и записать это в две строки:

```python
students_counter = students[name]
students_counter.done()
```

Важно: даже если мы присвоили объект вспомогательной переменной, он по‑прежнему остаётся в словаре. Вспомогательная переменная хранит _ссылку_ на объект из словаря.

Если вы не до конца уверены, что именно происходит в коде выше, попробуйте разобрать его с помощью [инструмента визуализации](http://www.pythontutor.com/visualize.html#mode=edit).

<programming-exercise name='Расширение телефонной книги, версия 2' anchor="Phone book expansion, version 2" tmcname='part10-11_phone_book_v2'>

В этом упражнении вы создадите другую версию `PhoneBookApplication`. Вы добавите адреса к данным, которые можно привязать к имени. Для простоты функциональность сохранения в файл удалена, а некоторые методы переименованы, чтобы лучше поддержать изменения.

## Отдельный класс для данных человека {#a-separate-class-for-a-persons-data}

Измените способ хранения данных человека. Реализуйте класс `Person`, который отвечает за номера телефонов и адреса человека. Класс должен работать так:

```python
person = Person("Eric")
print(person.name())
print(person.numbers())
print(person.address())
person.add_number("040-123456")
person.add_address("Mannerheimintie 10 Helsinki")
print(person.numbers())
print(person.address())
```

<sample-output>

Eric
[]
None
['040-123456']
Mannerheimintie 10 Helsinki

</sample-output>

## PhoneBook использует класс Person {#phonebook-uses-the-class-person}

Измените внутреннюю реализацию так, чтобы класс `PhoneBook` использовал объекты класса `Person` для хранения данных. То есть атрибут `__persons` по‑прежнему должен быть словарём, но значениями должны быть объекты `Person`, а не списки. Пользователь приложения не должен заметить разницы — изменения не должны затронуть пользовательский интерфейс.

**ВНИМАНИЕ:** когда вы делаете структурные изменения в коде (как в этом упражнении), двигайтесь маленькими шагами и тестируйте на каждом этапе. Не пытайтесь сделать всё сразу — это верный путь **к серьёзным проблемам в коде**.

Хороший первый шаг — написать небольшой код, который проверяет работу `PhoneBook` напрямую. Например, следующий код хотя бы не должен приводить к ошибкам:

```python
phonebook = PhoneBook()
phonebook.add_number("Eric", "02-123456")
print(phonebook.get_entry("Eric"))
print(phonebook.get_entry("Emily"))
```

Обратите внимание на новое имя метода для получения записи из телефонной книги. Автоматические тесты не проверяют точный текст вывода `get_entry`, но убедитесь, что приведённый выше код не вызывает ошибок и результат соответствует вашей реализации.

После того как вы внесли необходимые изменения и полностью проверили функциональность внутри `PhoneBook`, переходите к пользовательскому интерфейсу и убедитесь, что всё по‑прежнему работает как ожидается.

## Добавление адреса {#adding-an-address}

Реализуйте возможность добавлять адрес к записи в телефонной книге. Программа должна работать так:

<sample-output>

commands:
0 exit
1 add number
2 search
3 add address

command: **1**
name: **Eric**
number: **02-123456**

command: **3**
name: **Emily**
address: **Viherlaaksontie 7, Espoo**

command: **2**
name: **Eric**
02-123456
address unknown

command: **2**
name: **Emily**
number unknown
Viherlaaksontie 7, Espoo

command: **3**
name: **Eric**
address: **Linnankatu 75, Turku**

command: 2
name: **Eric**
02-123456
Linnankatu 75, Turku

command: **2**
name: **Wilhelm**
address unknown
number unknown

command: **0**

</sample-output>

**ВНИМАНИЕ и подсказка:** как сказано выше в предыдущем упражнении, не пытайтесь делать все изменения сразу. Это верный путь **к серьёзным проблемам в коде**.

Сначала убедитесь, что вы можете надёжно добавлять адреса, проверяя это напрямую через класс `PhoneBook`. После проверки переходите к необходимым изменениям в пользовательском интерфейсе.

</programming-exercise>

## Несколько заключительных замечаний {#some-concluding-remarks}

Структура примера с телефонной книгой выше довольно хорошо следует фундаментальным принципам ООП. Ключевая идея — определить разные зоны ответственности в программе и логично распределить их между классами и методами. Одна из основных причин такого разделения — управление сложностью. Другая важная причина — логичное разделение ответственности (модульность, говоря профессиональным языком) часто делает код проще в поддержке и расширении.

В программных продуктах, которые разрабатываются и используются в мире, самая дорогая часть жизненного цикла — это поддержка и развитие: исправление ошибок в существующем ПО и внедрение новых возможностей. Правильно реализованная модульность — финансово очень важная характеристика разработки.

Стоит выделить и ещё несколько принципов ООП. Телефонная книга — хороший пример того, как основную логику приложения можно (и нужно) отделять и от пользовательского интерфейса, и от механизмов хранения данных. Это важно по нескольким причинам. Во‑первых, такое разделение позволяет тестировать код меньшими частями — по одному классу и методу. Во‑вторых, когда основная логика независима от интерфейсов «внешнего мира», можно (в разумных пределах) менять реализацию логики или интерфейсов, не ломая всё приложение целиком.

Процесс работы с файлами в приложении телефонной книги устроен так: программа читает файл один раз при запуске. После этого все данные хранятся в переменных в памяти. При выходе программа снова сохраняет все данные, фактически перезаписывая файл. В большинстве случаев это рекомендуемый способ работы с внешними файлами, потому что изменять данные «на месте» часто гораздо сложнее.

Есть много хороших книг о практике качественного программирования. Одна из них — [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Роберта Мартина. Правда, примеры кода в книге написаны на Java, поэтому разбирать их может быть труднее на этом этапе, хотя саму книгу преподаватели курса очень рекомендуют. Темы поддерживаемого, расширяемого кода хорошего качества будут дальше изучаться на курсах
[Software Development Methods](https://studies.helsinki.fi/courses/cu/hy-CU-118024742-2020-08-01) и [Software Engineering](https://studies.helsinki.fi/courses/cu/hy-CU-118024909-2020-08-01).

Написание кода в соответствии с принципами ООП имеет свою «цену». Скорее всего, вы напишете больше кода, чем если бы сделали решение одним большим «спагетти‑скриптом». Один из ключевых навыков программиста — выбирать подход для каждой ситуации. Иногда нужно быстро «склепать» решение для немедленного использования. С другой стороны, если в обозримом будущем код будет переиспользоваться, поддерживаться или развиваться (вами или — что важнее — кем‑то другим), читаемость и логичная модульность становятся критически важными. Чаще всего, если что‑то стоит делать, то стоит делать хорошо — даже на ранних этапах разработки.

Чтобы завершить эту часть материалов, вы реализуете ещё одно более крупное приложение.

<programming-exercise name='Учёт курсов' anchor="CourseRecords" tmcname='part10-12_course_records'>

Напишите интерактивное приложение для учёта обучения. Внутренняя структура остаётся на ваше усмотрение, но это хорошая возможность потренироваться построить структуру, похожую на пример с телефонной книгой выше.

Программа должна работать так:

<sample-output>

1 add course
2 get course data
3 statistics
0 exit

command: **1**
course: **ItP**
grade: **3**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 3

command: **1**
course: **ItP**
grade: **5**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 5

command: **1**
course: **ItP**
grade: **1**
credits: **5**

command: **2**
course: **ItP**
ItP (5 cr) grade 5

command: **2**
course: **Introduction to Java**
no entry for this course

command: **1**
course: **ACiP**
grade: **1**
credits: **10**

command: **1**
course: **ItAI**
grade: **2**
credits: **5**

command: **1**
course: **Algo101**
grade: **4**
credits: **1**

command: **1**
course: **CompModels**
grade: **5**
credits: **8**

command: **3**
5 completed courses, a total of 29 credits
mean 3.4
grade distribution
5: xx
4: x
3:
2: x
1: x

command: **0**

</sample-output>

Каждое название курса должно соответствовать одной записи в журнале. Оценку можно повышать, повторно вводя данные курса, но понижать оценку нельзя.

Упражнение оценивается в два балла. Первый балл даётся, когда команды 1, 2 и 0 работают корректно. Второй — если команда 3 тоже работает как ожидается.

</programming-exercise>

## Эпилог {#epilogue}

Чтобы завершить этот раздел материалов, на минуту вернёмся к пользовательскому интерфейсу примера с телефонной книгой.

```python
class PhoneBookApplication:
    def __init__(self):
        self.__phonebook = PhoneBook()
        self.__filehandler = FileHandler("phonebook.txt")

    # ...остальная часть программы

application = PhoneBookApplication()
application.execute()
```

Объект `PhoneBookApplication` содержит и объект `PhoneBook`, и объект `FileHandler`. Имя файла, передаваемое в `FileHandler`, сейчас «зашито» (hard‑coded) прямо в `PhoneBookApplication`. Это совершенно несущественная деталь для _пользовательского интерфейса_ приложения. Более того, это нарушает принцип _разделения ответственности_: где `PhoneBook` хранит данные, не должно заботить `PhoneBookApplication`, но если мы захотим поменять файл, придётся менять код `PhoneBookApplication`.

Лучше создать объект `FileHandler` где‑то _вне_ класса `PhoneBookApplication` и передать его в приложение аргументом:

```python
class PhoneBookApplication:
    def __init__(self, storage_service):
        self.__phonebook = PhoneBook()
        self.__storage_service = storage_service

    # ...остальная часть пользовательского интерфейса

# создаём FileHandler
storage_service = FileHandler("phonebook.txt")
# передаём его аргументом в конструктор PhoneBookApplication
application = PhoneBookApplication(storage_service)
application.execute()
```

Так мы убираем _лишнюю зависимость_ из `PhoneBookApplication`. Если имя файла изменится, пользовательский интерфейс менять не нужно — достаточно передать в конструктор другой аргумент:

```python
class PhoneBookApplication:
    def __init__(self, filename):
        self.__phonebook = PhoneBook()
        self.__filename = filename

    # ...остальная часть пользовательского интерфейса

# используем другое имя файла
storage_service = FileHandler("new_phonebook.txt")
application = PhoneBookApplication(storage_service)
application.execute()
```

Такое изменение также позволяет рассмотреть более «экзотические» места хранения — например, облачный сервис в интернете. Нужно лишь реализовать класс, который работает с облаком и предоставляет `PhoneBookApplication` тот же набор методов, что и `FileHandler`.

Экземпляр этого нового «облачного обработчика» можно передать в конструктор, и в пользовательском интерфейсе не придётся менять ни строчки:

```python
class CloudHandler:
    # код для сохранения телефонной книги
    # в облачный сервис в интернете

storage_service = CloudHandler("amazon-cloud", "username", "passwrd")
application = PhoneBookApplication(storage_service)
application.execute()
```

Как вы уже видели, такие техники имеют свою «цену»: нужно писать больше кода, поэтому программист должен оценивать, оправдан ли такой компромисс.

Описанная выше техника называется _внедрением зависимостей_ (dependency injection). Как следует из названия, идея в том, чтобы предоставлять объекту все необходимые зависимости _снаружи_, а не создавать их внутри объекта. Это очень полезный инструмент: он облегчает добавление новых возможностей и помогает автоматическому тестированию. Подробнее тема будет рассматриваться на упомянутых курсах [Software Development Methods](https://studies.helsinki.fi/courses/cu/hy-CU-118024742-2020-08-01) и [Software Engineering](https://studies.helsinki.fi/courses/cu/hy-CU-118024909-2020-08-01).

Пожалуйста, ответьте на небольшой опрос по этой части курса.

<quiz id="f56ab364-0556-5d73-90d1-12c47de1fe75"></quiz>
