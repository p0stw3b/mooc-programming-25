---
path: /ru/part-5/1-more-lists
title: Ещё о списках
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы сможете создавать списки с элементами разных типов
- вы узнаете, как использовать списки для организации данных
- вы сможете хранить матрицу как двумерный список

</text-box>

<!--тот же текст есть в разделах 3-1, 5-1 и 6-1; если меняете здесь — проверьте и там-->
<text-box variant='hint' name="Об упражнениях на этом курсе">

Чтобы стать уверенным программистом, нужно много практиковаться — иногда даже довольно «механически». Также важно развивать навыки решения задач и интуицию. Поэтому в этом курсе много упражнений разных типов. Некоторые из них предлагают просто применить то, что вы только что изучили, а некоторые намеренно сделаны более сложными и открытыми.

Некоторые упражнения поначалу могут показаться слишком трудными — это нормально и не повод переживать. Ни одно упражнение не является строго обязательным, и на самом деле _для прохождения курса достаточно набрать лишь 25% баллов в каждой части_. Подробнее — на [странице об оценивании](/ru/grading-and-exams).

**Упражнения не расположены в порядке сложности.** Обычно в каждом разделе вводятся новые концепции, а затем они закрепляются упражнениями — как простыми, так и более сложными. **Если вам попалось упражнение, которое кажется слишком трудным, переходите к следующему.** К сложным упражнениям можно вернуться позже, если останется время.

И когда (неизбежно) станет трудно, небольшое утешение: задача, которая кажется невозможной на этой неделе, через четыре недели, скорее всего, покажется довольно простой.

</text-box>

## Списки с разными типами данных {#lists-with-different-types-of-data}

В предыдущей части мы в основном работали со списками целых чисел, но в списках можно хранить значения любых типов. Например, список строк может выглядеть так:

```python
names = ["Marlyn", "Ruth", "Paul"]
print(names)
names.append("David")
print(names)

print("Number of names on the list:", len(names))
print("Names in alphabetical order:")
names.sort()
for name in names:
  print(name)
```

<sample-output>

['Marlyn', 'Ruth', 'Paul']
['Marlyn', 'Ruth', 'Paul', 'David']
Number of names on the list: 4
Names in alphabetical order:
David
Marlyn
Paul
Ruth

</sample-output>

Вещественные числа тоже могут быть элементами списка:

```python
measurements = [-2.5, 1.1, 7.5, 14.6, 21.0, 19.2]

for measure in measurements:
    print(measure)

mean = sum(measurements) / len(measurements)

print("The mean is:", mean)
```

<sample-output>

-2.5
1.1
7.5
14.6
21.0
19.2
The mean is: 10.15

</sample-output>

<!--похожее предупреждение есть в разделах 3-4, 4-6 и 5-1; если меняете здесь — проверьте и там-->
## Напоминание: использование глобальных переменных внутри функций {#reminder-using-global-variables-within-functions}

Мы знаем, что внутри функции можно создавать новые переменные. При этом функция «видит» и переменные, которые объявлены снаружи, в основной части программы. Такие переменные называются _глобальными_.

Использовать глобальные переменные внутри функций обычно плохая идея. Помимо прочего, это может привести к ошибкам, которые сложно обнаружить и отладить.

Ниже пример функции, которая «случайно» использует глобальную переменную:

```python
def print_reversed(names: list):
    # по ошибке используем глобальную переменную вместо параметра
    i = len(name_list) - 1
    while i >= 0:
        print(name_list[i])
        i -= 1

# здесь присваивается глобальная переменная
name_list = ["Steve", "Jean", "Katherine", "Paul"]
print_reversed(name_list)
print()
print_reversed(["Huey", "Dewey", "Louie"])
```

<sample-output>

Paul
Katherine
Jean
Steve

Paul
Katherine
Jean
Steve

</sample-output>

Хотя в обоих вызовах функции передан корректный аргумент, функция всё равно печатает то, что хранится в глобальной переменной `name_list`.

Ситуацию ещё больше запутывает то, что весь код для тестирования своих функций нужно помещать в блок `if __name__ == "__main__":`, чтобы автоматические тесты работали правильно. Предыдущий пример должен выглядеть так:

```python
def print_reversed(names: list):
    # по ошибке используем глобальную переменную вместо параметра
    i = len(name_list) - 1
    while i>=0:
        print(name_list[i])
        i -= 1

# Весь код для тестирования функции должен быть внутри этого блока
if __name__ == "__main__":
    # здесь присваивается глобальная переменная
    name_list = ["Steve", "Jean", "Katherine", "Paul"]
    print_reversed(name_list)
    print()
    print_reversed(["Huey", "Dewey", "Louie"])
```

Обратите внимание: теперь глобальная переменная присваивается внутри блока `if`.

Автоматические тесты в системе TMC выполняются без запуска кода внутри блока `if`. Поэтому во втором варианте пример даже теоретически не заработал бы в тестах: функция обращается к `name_list`, а этой переменной вообще не существует во время выполнения тестов.

## Внимание: перезапись параметра и слишком ранний `return` {#warning-overwriting-a-parameter-and-returning-too-early}

Прежде чем перейти к упражнениям этой части, разберём ещё пару распространённых источников ошибок. Посмотрим на функцию, которая должна определять, есть ли заданное целое число в списке. И список, и число передаются параметрами:

```python
def number_in_list(numbers: list, number: int):
    for number in numbers:
        if number == number:
            return True
        else:
            return False
```

Кажется, что эта функция всегда возвращает `True`. Причина в том, что цикл `for` перезаписывает значение параметра `number`: переменная цикла называется так же. Поэтому условие в `if` всегда истинно.

Если переименовать параметр, проблема исчезает:

```python
def number_in_list(numbers: list, searched_number: int):
    for number in numbers:
        if number == searched_number:
            return True
        else:
            return False
```

Теперь условие в `if` выглядит правильно. Но появляется другая проблема: функция всё равно работает неверно. Например, если выполнить:

```python
found = number_in_list([1, 2, 3, 4], 3)
print(found)  # выводит False
```

Проблема в том, что функция слишком рано делает `return`, не проверив все элементы списка. По сути она рассматривает только первый элемент и сразу возвращает `True` или `False` в зависимости от него. Мы не можем утверждать, что число _отсутствует_ в списке, пока не проверили все элементы. Поэтому `return False` нужно разместить _после_ цикла `for`:

```python
def number_in_list(numbers: list, searched_number: int):
    for number in numbers:
        if number == searched_number:
            return True

    return False
```

Рассмотрим ещё одну ошибочную функцию:

```python
def unique_numbers(numbers: list):
    # вспомогательная переменная для хранения уже проверенных чисел
    numbers = []
    for number in numbers:
        # встречалось ли это число раньше?
        if number in numbers:
            return False
        numbers.append(number)

    return True

unique = unique_numbers([1, 2, 2])
print(unique)  # выводит True
```

Эта функция должна проверять, что все числа в списке различны, но она всегда возвращает `True`.

Здесь функция снова по ошибке перезаписывает значение параметра. Она пытается использовать переменную `numbers`, чтобы хранить уже проверенные значения, но тем самым затирает исходный список‑аргумент. Достаточно переименовать вспомогательную переменную:

```python
def unique_numbers(numbers: list):
    # вспомогательная переменная для хранения уже проверенных чисел
    numbers_checked = []
    for number in numbers:
        # встречалось ли это число раньше?
        if number in numbers_checked:
            return False
        numbers_checked.append(number)

    return True

unique = unique_numbers([1, 2, 2])
print(unique)  # выводит False
```

Похожие проблемы (и многие другие) можно находить и исправлять с помощью отладчика или [инструмента визуализации](http://www.pythontutor.com/visualize.html#mode=edit). Важность умения эффективно пользоваться такими инструментами трудно переоценить.

<programming-exercise name='Самая длинная строка' anchor="The longest string" tmcname='part05-01_longest_string'>

Напишите функцию `longest(strings: list)`, которая принимает список строк. Функция должна найти и вернуть самую длинную строку в списке. Можно считать, что самая длинная строка всегда одна.

Пример ожидаемого поведения:

```python

if __name__ == "__main__":
    strings = ["hi", "hiya", "hello", "howdydoody", "hi there"]
    print(longest(strings))

```

<sample-output>

howdydoody

</sample-output>

</programming-exercise>

## Списки в списках {#lists-within-lists}

Элементами списка могут быть и другие списки:

```python
my_list = [[5, 2, 3], [4, 1], [2, 2, 5, 1]]
print(my_list)
print(my_list[1])
print(my_list[1][0])
```
<sample-output>

[[5, 2, 3], [4, 1], [2, 2, 5, 1]]
[4, 1]
4

</sample-output>

Зачем могут понадобиться списки в списках?

Напомним, что списки могут содержать элементы разных типов. Например, в списке можно хранить информацию о человеке: имя первым элементом, возраст вторым, рост (в метрах) третьим:

```python
["Anne", 12, 1.45]
```

Тогда «база данных» людей может быть списком, элементы которого — списки с информацией об одном человеке:

```python
persons = [["Betty", 10, 1.37], ["Peter", 7, 1.25], ["Emily", 32, 1.64], ["Alan", 39, 1.78]]

for person in persons:
  name = person[0]
  age = person[1]
  height = person[2]
  print(f"{name}: age {age} years, height {height} meters")
```

<sample-output>

Betty: age 10 years, height 1.37 meters
Peter: age 7 years, height 1.25 meters
Emily: age 32 years, height 1.64 meters
Alan: age 39 years, height 1.78 meters

</sample-output>

Цикл `for` перебирает элементы внешнего списка. То есть каждый список с данными о человеке по очереди присваивается переменной `person`.

Списки не всегда лучший способ представлять данные, например информацию о человеке. Скоро мы познакомимся со структурами данных _словарями_ (dictionaries) в Python — они часто лучше подходят для таких задач.

## Матрицы {#matrices}

Двумерный массив, или _матрица_, — ещё один естественный пример использования списков в списках.

Например, матрицу

<img src="5_1_1.png">

можно представить в Python как двумерный список:

```python
my_matrix = [[1, 2, 3], [3, 2, 1], [4, 5, 6]]
```

Так как матрица — это список списков, к отдельным элементам можно обращаться с помощью двух пар квадратных скобок. Первый индекс — номер строки, второй — номер столбца. Индексация начинается с нуля, поэтому, например, `my_matrix[0][1]` — это второй элемент первой строки.

```python
my_matrix = [[1, 2, 3], [3, 2, 1], [4, 5, 6]]

print(my_matrix[0][1])
my_matrix[1][0] = 10
print(my_matrix)
```

<sample-output>

2
[[1, 2, 3], [10, 2, 1], [4, 5, 6]]

</sample-output>

Как и любой список, строки матрицы можно перебрать циклом `for`. Следующий код печатает каждую строку матрицы на отдельной строке:

```python
my_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_matrix:
    print(row)
```

<sample-output>

[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

</sample-output>

А чтобы добраться до отдельных элементов, можно использовать вложенные циклы. Следующий код печатает каждый элемент матрицы на отдельной строке с помощью двух циклов `for`:

```python
my_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_matrix:
    print("a new row")
    for element in row:
        print(element)
```

<sample-output>

a new row
1
2
3
a new row
4
5
6
a new row
7
8
9

</sample-output>

## Визуализация кода со списками в списках {#visualising-code-containing-lists-within-lists}

Программы со списками в списках поначалу могут казаться сложными. Отлично помогает [инструмент визуализации](http://www.pythontutor.com/visualize.html) от Python Tutor. Ниже показана визуализация предыдущего примера:

<img src="5_1_2.png">

На картинке видно, что матрица 3×3 технически состоит из четырёх списков. Первый список представляет всю матрицу, а три оставшихся списка — элементы первого списка — представляют строки.

Поскольку многомерные списки перебирают вложенными циклами, может показаться, что списки «вложены» друг в друга буквально. Но картинка показывает, что это не совсем так: список, представляющий матрицу целиком, «указывает» (ссылается) на отдельные списки‑строки. Это называется _ссылкой_ (reference), и в [следующем разделе](/ru/part-5/2-references) мы разберём эту идею подробнее.

В показанный момент выполнения программа дошла до второй строки матрицы, и именно на этот список сейчас указывает переменная `row`. Переменная `element` содержит элемент, который обрабатывается в данный момент. Это средний элемент списка, то есть 5.

## Доступ к элементам матрицы {#accessing-items-in-a-matrix}

Доступ к отдельной строке матрицы прост: нужно выбрать нужную строку. Следующая функция вычисляет сумму элементов выбранной строки:

```python
def sum_of_row(my_matrix, row_no: int):
    # выбрать нужную строку в матрице
    row = my_matrix[row_no]
    row_sum = 0
    for item in row:
        row_sum += item

    return row_sum

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

my_sum = sum_of_row(m, 1)
print(my_sum) # выводит 33 (то есть 9 + 1 + 12 + 11)
```

Работа со столбцами немного сложнее, потому что матрица хранится по строкам:

```python
def sum_of_column(my_matrix, column_no: int):
    # пройти по каждой строке и взять элемент в нужной позиции
    column_sum = 0
    for row in my_matrix:
        column_sum += row[column_no]

    return column_sum

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

my_sum = sum_of_column(m, 2)
print(my_sum) # выводит 39 (то есть 3 + 12 + 9 + 15)
```

Рассматриваемый столбец состоит из элементов с индексом 2 _в каждой строке_.

Чтобы понять, как работают такие функции, определённо стоит воспользоваться [инструментом визуализации](http://www.pythontutor.com/visualize.html).

Изменить значение одного элемента матрицы тоже просто: выбираем строку, затем — столбец внутри строки:

```python
def change_value(my_matrix, row_no: int, column_no: int, new_value: int):
    # выбрать нужную строку
    row = my_matrix[row_no]
    # выбрать нужный элемент внутри строки
    row[column_no] = new_value

m = [[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]

print(m)
change_value(m, 2, 3, 1000)
print(m)
```

<sample-output>

[[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 5], [2, 9, 15, 1]]
[[4, 2, 3, 2], [9, 1, 12, 11], [7, 8, 9, 1000], [2, 9, 15, 1]]

</sample-output>

Обратите внимание: выше мы использовали индексы строки и столбца, чтобы обратиться к нужному элементу. Если мы хотим менять содержимое матрицы, нужно обращаться к элементам по индексам. Это означает, что простой перебор вида `for item in list` не подходит, если требуется изменять элементы.

Вместо этого нужно отслеживать индексы элементов — например, с помощью `while` или с помощью `for` в сочетании с `range`. Следующий код увеличивает каждый элемент матрицы на единицу:

```python
m = [[1,2,3], [4,5,6], [7,8,9]]

for i in range(len(m)): # используем количество строк в матрице
    for j in range(len(m[i])): # используем количество элементов в каждой строке
        m[i][j] += 1

print(m)
```

<sample-output>

[[2, 3, 4], [5, 6, 7], [8, 9, 10]]

</sample-output>

Внешний цикл перебирает индексы от 0 до длины матрицы, то есть количество строк. Внутренний цикл перебирает индексы от 0 до длины соответствующей строки.

<programming-exercise name='Количество совпадающих элементов' anchor="Number of matching elements" tmcname='part05-02_number_of_elements'>

Напишите функцию `count_matching_elements(my_matrix: list, element: int)`, которая принимает двумерный массив целых чисел и одно целое число. Функция должна посчитать, сколько элементов матрицы равны переданному значению.

Пример работы функции:

```python
m = [[1, 2, 1], [0, 3, 4], [1, 0, 0]]
print(count_matching_elements(m, 1))
```

<sample-output>

3

</sample-output>

</programming-exercise>

## Двумерный массив как структура данных в игре {#a-two-dimensional-array-as-a-data-structure-in-a-game}

Матрица может быть очень полезной структурой данных во многих играх. Например, поле судоку на изображении ниже

<img src="5_1_3.png">

можно представить в виде матрицы так:

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [0, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [0, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]
```

Здесь ноль означает пустую клетку, потому что в решённом судоку ноль не может быть значением.

Вот простая функция, которая печатает такую сетку судоку:

```python
def print_grid(sudoku):
    for row in sudoku:
        for square in row:
            if square > 0:
                print(f" {square}", end="")
            else:
                print(" _", end="")
        print()

print_grid(sudoku)
```

Вывод должен выглядеть так:

```x

 9 _ _ _ 8 _ 3 _ _
 _ _ _ 2 5 _ 7 _ _
 _ 2 _ 3 _ _ _ _ 4
 _ 9 4 _ _ _ _ _ _
 _ _ _ 7 3 _ 5 6 _
 7 _ 5 _ 6 _ 4 _ _
 _ _ 7 8 _ 3 9 _ _
 _ _ 1 _ _ _ _ _ 3
 3 _ _ _ _ _ _ _ 2

```

Почти любую игру с игровым полем можно моделировать похожим образом. Например, шахматы, «Сапёр», «Морской бой» или Mastermind — все они основаны на двумерной сетке. Для судоку естественно использовать числа, но для других игр могут лучше подойти другие способы представления состояния.

<programming-exercise name='Го' anchor="Go" tmcname='part05-03_go'>

В игре «Го» два игрока по очереди ставят на доску чёрные и белые камни. Побеждает игрок, которому удаётся окружить на доске большую территорию своими камнями.

Напишите функцию `who_won(game_board: list)`, которая принимает двумерный массив. В массиве хранятся целые числа, которые означают:

* 0: пустая клетка
* 1: фишка игрока 1
* 2: фишка игрока 2

Правила подсчёта очков в го довольно сложные, но в этом упражнении достаточно сравнить количество камней каждого игрока на доске. Размер поля не ограничен.

Функция должна вернуть 1, если победил игрок 1, и 2 — если победил игрок 2. Если у игроков одинаковое количество камней на доске, функция должна вернуть 0.

</programming-exercise>

<programming-exercise name='Судоку: проверка строки' anchor="Sudoku: check row" tmcname='part05-04_sudoku_row'>

Напишите функцию `row_correct(sudoku: list, row_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и целое число — номер строки. Индексация строк начинается с 0.

Функция должна вернуть `True` или `False` в зависимости от того, заполнена ли строка корректно: то есть содержит ли она каждое число от 1 до 9 не более одного раза.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(row_correct(sudoku, 0))
print(row_correct(sudoku, 1))
```

<sample-output>

True
False

</sample-output>

</programming-exercise>

<programming-exercise name='Судоку: проверка столбца' anchor="Sudoku: check column" tmcname='part05-05_sudoku_column'>

Напишите функцию `column_correct(sudoku: list, column_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и целое число — номер столбца. Индексация столбцов начинается с 0.

Функция должна вернуть `True` или `False` в зависимости от того, заполнен ли столбец корректно: то есть содержит ли он каждое число от 1 до 9 не более одного раза.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(column_correct(sudoku, 0))
print(column_correct(sudoku, 1))
```

<sample-output>

False
True

</sample-output>

</programming-exercise>

<programming-exercise name='Судоку: проверка блока' anchor="Sudoku: check block" tmcname='part05-06_sudoku_block'>

Напишите функцию `block_correct(sudoku: list, row_no: int, column_no: int)`, которая принимает двумерный массив, представляющий сетку судоку, и два целых числа — индекс строки и индекс столбца одной клетки. Индексация строк и столбцов начинается с 0.

Функция должна вернуть `True` или `False` в зависимости от того, заполнен ли корректно блок 3×3, который начинается в указанной клетке и идёт вправо и вниз. То есть содержит ли этот блок каждое число от 1 до 9 не более одного раза.

Обратите внимание: эта функция не полностью соответствует правилам судоку. В настоящем судоку нужно проверять только 9 блоков, и они начинаются в клетках с индексами (0, 0), (0, 3), (0, 6), (3, 0), (3, 3), (3, 6), (6, 0), (6, 3) и (6, 6). В этом упражнении такие ограничения реализовывать не нужно.

```python
sudoku = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(block_correct(sudoku, 0, 0))
print(block_correct(sudoku, 1, 2))
```

<sample-output>

False
True

</sample-output>

Первый вызов функции должен проверить блок 3×3, который начинается с клетки с индексами `0, 0`:

<pre>
9 0 0
2 0 0
0 2 0
</pre>

Второй вызов функции должен проверить блок 3×3, который начинается с клетки в строке 1 и столбце 2:

<pre>
0 2 5
0 3 0
4 0 0
</pre>

В настоящем судоку такой блок не проверяют, но ваша функция должна позволять его проверить.

</programming-exercise>

<programming-exercise name='Судоку: проверка всей сетки' anchor="Sudoku: check grid" tmcname='part05-07_sudoku_grid'>

Напишите функцию `sudoku_grid_correct(sudoku: list)`, которая принимает двумерный массив, представляющий сетку судоку. Функция должна использовать функции из трёх предыдущих упражнений, чтобы определить, корректно ли заполнена вся сетка. Скопируйте функции из предыдущих упражнений в файл решения этого задания.

Функция должна проверить каждую из девяти строк, столбцов и блоков 3×3. Если все они содержат числа от 1 до 9 не более одного раза, функция возвращает `True`. Если хотя бы одно условие нарушено, функция возвращает `False`.

На картинке с сеткой судоку выше блоки 3×3 выделены более толстыми границами. Именно эти блоки нужно проверять, и они начинаются в клетках с индексами (0, 0), (0, 3), (0, 6), (3, 0), (3, 3), (3, 6), (6, 0), (6, 3) и (6, 6).

```python
sudoku1 = [
  [9, 0, 0, 0, 8, 0, 3, 0, 0],
  [2, 0, 0, 2, 5, 0, 7, 0, 0],
  [0, 2, 0, 3, 0, 0, 0, 0, 4],
  [2, 9, 4, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 7, 3, 0, 5, 6, 0],
  [7, 0, 5, 0, 6, 0, 4, 0, 0],
  [0, 0, 7, 8, 0, 3, 9, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0, 3],
  [3, 0, 0, 0, 0, 0, 0, 0, 2]
]

print(sudoku_grid_correct(sudoku1))

sudoku2 = [
  [2, 6, 7, 8, 3, 9, 5, 0, 4],
  [9, 0, 3, 5, 1, 0, 6, 0, 0],
  [0, 5, 1, 6, 0, 0, 8, 3, 9],
  [5, 1, 9, 0, 4, 6, 3, 2, 8],
  [8, 0, 2, 1, 0, 5, 7, 0, 6],
  [6, 7, 4, 3, 2, 0, 0, 0, 5],
  [0, 0, 0, 4, 5, 7, 2, 6, 3],
  [3, 2, 0, 0, 8, 0, 0, 5, 7],
  [7, 4, 5, 0, 0, 3, 9, 0, 1]
]

print(sudoku_grid_correct(sudoku2))
```

<sample-output>

False
True

</sample-output>

</programming-exercise>

<!---
Тест для повторения материала этого раздела:

<quiz id="ccb6dcbf-1065-513f-9294-15f42a318300"></quiz>
-->
