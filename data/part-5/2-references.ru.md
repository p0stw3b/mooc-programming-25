---
path: /ru/part-5/2-references
title: Ссылки
hidden: false
---

<text-box variant='learningObjectives' name="Цели обучения">

После этого раздела:

- вы будете понимать, что означает ссылка (reference) переменной
- вы поймёте, что на один и тот же объект могут указывать несколько ссылок
- вы сможете использовать списки как параметры функций
- вы узнаете, что называют побочным эффектом (side effect) функции

</text-box>

До сих пор мы представляли переменную как «коробку», в которой лежит её значение. Технически в Python это не так. В переменной хранится не само значение, а _ссылка_ (reference) на _объект_, который и является фактическим значением. Объектом может быть, например, число, строка или список.

На практике это означает, что значение переменной _не хранится_ в самой переменной. Вместо этого в переменной хранится информация о том, где в памяти компьютера находится значение.

Ссылку часто изображают стрелкой от переменной к значению в памяти:

<img src="5_2_1.png">

То есть ссылка показывает, где можно найти значение. Функция `id` позволяет узнать точный «адрес», на который указывает переменная:

```python
a = [1, 2, 3]
print(id(a))
b = "This is a reference, too"
print(id(b))
```

<sample-output>

4538357072
4537788912

</sample-output>

Ссылка (ID переменной) — это целое число. Его можно представить как адрес в памяти, где хранится значение. Если вы выполните этот код на своём компьютере, числа, скорее всего, будут другими: ваши переменные будут указывать на другие области памяти.

Инструмент визуализации Python Tutor тоже показывает ссылки стрелками от переменной к содержимому, как мы видели в [предыдущем разделе](/ru/part-5/1-more-lists#visualising-code-containing-lists-within-lists). Однако со строками он немного «хитрит»: отображает строки так, будто они хранятся прямо в переменных:

<img src="5_2_2.png">

На самом деле строки в Python устроены очень похоже на списки: тоже используются ссылки на области памяти.

Многие встроенные типы Python, например `str`, _неизменяемы_ (immutable). Это означает, что значение объекта (или его часть) не может измениться. При этом переменную можно «переназначить» на новое значение:

<img src="5_2_3.png">

Некоторые типы в Python _изменяемы_ (mutable). Например, содержимое списка можно менять без создания нового списка:

<img src="5_2_4.png">

Возможно, вас удивит, что даже базовые типы `int`, `float` и `bool` в Python тоже неизменяемы. Посмотрите на такой код:

```python
number = 1
number = 2
number += 10
```

Кажется, что команды просто меняют значение переменной, но на самом деле каждая команда создаёт новое число в памяти.

Вывод следующей программы проясняет ситуацию:

```python
number = 1
print(id(number))
number += 10
print(id(number))
a = 1
print(id(a))
```

<sample-output>

4535856912
4535856944
4535856912

</sample-output>

Сначала переменная `number` указывает на область памяти 4535856912. Когда `number` получает новое значение, она начинает указывать на область 4535856944. Затем переменной `a` присваивается значение 1, и `a` указывает на то же место, куда раньше указывала `number`, когда ей тоже было присвоено 1.

Похоже, Python хранит значение 1 в области памяти 4535856912. Когда переменной присваивается 1, переменная _ссылается_ на эту область памяти.

Полезно помнить, что в Python _почти всё является ссылкой_, но в повседневных задачах это редко важно. Вернёмся к более практичным вопросам.

## Несколько ссылок на один и тот же список {#multiple-references-to-the-same-list}

Что происходит, когда вы присваиваете переменную со списком другой переменной — копируется ли список?

```python
a = [1, 2, 3]
b = a
b[0] = 10
```

Присваивание `b = a` копирует значение, хранящееся в переменной `a`, в переменную `b`. Но значение в `a` — это не сам список, а _ссылка_ на список.

То есть `b = a` копирует именно ссылку. В результате у нас оказываются две ссылки на одну и ту же область памяти со списком.

<img src="5_2_5.png">

К списку можно обратиться через любую из двух ссылок:

```python
list1 = [1, 2, 3, 4]
list2 = list1

list1[0] = 10
list2[1] = 20

print(list1)
print(list2)
```

<sample-output>

[10, 20, 3, 4]
[10, 20, 3, 4]

</sample-output>

Если на один и тот же список есть несколько ссылок, любая из них позволяет получить доступ к списку. Но и изменения, сделанные через любую ссылку, будут видны через все остальные ссылки, потому что «цель» у них одна и та же.

И здесь снова отлично помогает инструмент визуализации:

<img src="5_2_6.png">

## Копирование списка {#copying-a-list}

Если вам нужна настоящая отдельная копия списка, можно создать новый список и по очереди добавить в него все элементы исходного списка:


```python
my_list = [1, 2, 3, 3, 5]

new_list = []
for item in my_list:
    new_list.append(item)

new_list[0] = 10
new_list.append(6)
print("the original:", my_list)
print("the copy:", new_list)
```

<sample-output>

my_list [1, 2, 3, 3, 5]
new_list [10, 2, 3, 3, 5, 6]

</sample-output>

Снимок процесса копирования в инструменте визуализации:

<img src="5_2_7.png">

Переменная `new_list` указывает на другой список, чем переменная `my_list`.

Более простой способ скопировать список — использовать оператор `[]`, который мы раньше применяли для срезов. Запись `[:]` выбирает все элементы коллекции. В качестве побочного эффекта она создаёт копию списка:

```python
my_list = [1,2,3,4]
new_list = my_list[:]

my_list[0] = 10
new_list[1] = 20

print(my_list)
print(new_list)
```

<sample-output>

[10, 2, 3, 4]
[1, 20, 3, 4]

</sample-output>

## Списки как параметры функций {#using-lists-as-parameters-in-functions}

Когда вы передаёте список в функцию как аргумент, вы передаёте ссылку на этот список. Это означает, что функция может изменять список напрямую.

Следующая функция принимает список и добавляет новый элемент в конец списка:

```python
def add_item(my_list: list):
    new_item = 10
    my_list.append(new_item)

a_list = [1,2,3]
print(a_list)
add_item(a_list)
print(a_list)
```

<sample-output>
[1, 2, 3]
[1, 2, 3, 10]
</sample-output>

Обратите внимание: у функции `add_item` нет возвращаемого значения. Она просто изменяет список, который получила аргументом.

Инструмент визуализации может помочь понять, что происходит:

<img src="5_2_8.png">

_Global frame_ относится к переменным, определённым в основной части программы, а кадр *add_item* (с голубым фоном) представляет параметры и переменные внутри функции. Как видно на визуализации, функция `add_item` ссылается на тот же самый список, что и основной код. Поэтому изменения внутри `add_item` видны и снаружи.

Другой способ реализовать ту же идею — создать внутри функции новый список и вернуть его:

```python
def add_item(my_list: list) -> list:
    new_item = 10
    my_list_copy = my_list[:]
    my_list_copy.append(new_item)
    return my_list_copy

numbers = [1, 2, 3]
numbers2 = add_item(numbers)

print("original list:", numbers)
print("new list:", numbers2)
```

<sample-output>

original list: [1, 2, 3]
new list: [1, 2, 3, 10]

</sample-output>

Если вы не уверены, что до конца понимаете, что происходит в коде выше, обязательно разберите его в инструменте визуализации.

## Изменение списка, переданного аргументом {#editing-a-list-given-as-an-argument}

Ниже попытка написать функцию, которая должна увеличить каждый элемент списка на 10:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)
    my_list = new_list

numbers = [1, 2, 3]
print("in the beginning:", numbers)
augment_all(numbers)
print("after the function is executed:", numbers)
```

<sample-output>

in the beginning: [1, 2, 3]
after the function is executed: [1, 2, 3]

</sample-output>

Почему‑то функция не работает. Что происходит?

Функция получает _ссылку_ на список, и эта ссылка хранится в переменной `my_list`. Присваивание `my_list = new_list` задаёт новое значение этой переменной. Теперь `my_list` указывает на новый список, созданный внутри функции, а ссылка на исходный список становится недоступной внутри функции. Однако это присваивание никак не влияет на переменную снаружи функции.

<!---
Следующая последовательность изображений показывает состояния переменных на разных этапах выполнения функции:

<img src="5_2_9.png" width="400">
-->

Кроме того, переменная `new_list`, в которой лежат новые значения, недоступна снаружи функции. Она «теряется», когда выполнение функции заканчивается и управление возвращается в основную часть программы. Переменная `numbers` в основной части всегда указывает на исходный список.

И здесь инструмент визуализации — ваш друг. Внимательно посмотрите на этапы выполнения и убедитесь, что исходный список вообще не меняется:

<img src="5_2_10.png">

Один из способов исправить это — по одному скопировать все элементы из нового списка в старый:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)

    # скопировать элементы из нового списка в старый
    for i in range(len(my_list)):
        my_list[i] = new_list[i]
```

В Python есть и удобная сокращённая запись для присваивания сразу нескольких элементов коллекции:

```python
>>> my_list = [1, 2, 3, 4]
>>> my_list[1:3] = [10, 20]
>>> my_list
[1, 10, 20, 4]
```

В примере выше срезу списка присваиваются значения из другой коллекции.

Как мы знаем, срез может охватывать всю коллекцию целиком:

```python
>>> my_list = [1, 2, 3, 4]
>>> my_list[:] = [100, 99, 98, 97]
>>> my_list
[100, 99, 98, 97]
```

В результате полностью заменяется содержимое старого списка. Вдохновившись этим, рабочий вариант функции может выглядеть так:

```python
def augment_all(my_list: list):
    new_list = []
    for item in my_list:
        new_list.append(item + 10)

    my_list[:] = new_list
```

Вообще говоря, создавать новый список внутри функции вовсе не обязательно. Можно просто записывать новые значения прямо в исходный список:

```python
def augment_all(my_list: list):
    for i in range(len(my_list)):
        my_list[i] += 10

```


<programming-exercise name='Элементы, умноженные на два' anchor="Items multiplied by two" tmcname='part05-08_items_multiplied_by_two'>

Напишите функцию `double_items(numbers: list)`, которая принимает список целых чисел.

Функция должна вернуть новый список, где каждое значение исходного списка умножено на 2. Функция _не должна_ изменять исходный список.

Пример работы функции:

```python
if __name__ == "__main__":
    numbers = [2, 4, 5, 3, 11, -4]
    numbers_doubled = double_items(numbers)
    print("original:", numbers)
    print("doubled:", numbers_doubled)
```
<sample-output>

original: [2, 4, 5, 3, 11, -4]
doubled: [4, 8, 10, 6, 22, -8]

</sample-output>

</programming-exercise>


<programming-exercise name='Удалить минимальный элемент' anchor="Remove the smallest" tmcname='part05-09_remove_smallest'>

Напишите функцию `remove_smallest(numbers: list)`, которая принимает список целых чисел.

Функция должна найти и удалить наименьший элемент списка. Можно считать, что наименьший элемент всегда один.

Функция не должна ничего возвращать — она должна напрямую изменить список, который получила аргументом.

Пример работы функции:

```python
if __name__ == "__main__":
    numbers = [2, 4, 6, 1, 3, 5]
    remove_smallest(numbers)
    print(numbers)
```
<sample-output>

[2, 4, 6, 3, 5]

</sample-output>

</programming-exercise>


<programming-exercise name='Судоку: печать сетки и добавление числа' anchor="Sudoku: print out the grid and add a number" tmcname='part05-10_sudoku_print_and_add'>

В этом упражнении мы допишем ещё две функции для проекта «судоку» из предыдущего раздела: `print_sudoku` и `add_number`.

Функция `print_sudoku(sudoku: list)` принимает двумерный массив, представляющий сетку судоку. Она должна печатать сетку в формате, показанном в примерах ниже.

Функция `add_number(sudoku: list, row_no: int, column_no: int, number: int)` принимает двумерный массив, представляющий судоку, два целых числа — индекс строки и индекс столбца одной клетки — и одну цифру от 1 до 9. Функция должна записать эту цифру в указанную клетку сетки.

```python
sudoku  = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
]

print_sudoku(sudoku)
add_number(sudoku, 0, 0, 2)
add_number(sudoku, 1, 2, 7)
add_number(sudoku, 5, 7, 3)
print()
print("Three numbers added:")
print()
print_sudoku(sudoku)
```

<sample-output>

<pre>
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

Three numbers added:

2 _ _  _ _ _  _ _ _
_ _ 7  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ 3 _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

</pre>

</sample-output>

**Подсказка**

Помните, что `print` можно вызывать без перевода строки:

```python
print("characters ", end="")
print("without carriage returns", end="")
```

<sample-output>

characters without carriage returns

</sample-output>

Иногда нужна только новая строка — её можно получить вызовом `print` без аргументов:

```python
print()
```

</programming-exercise>

<programming-exercise name='Судоку: добавление числа в копию сетки' anchor="Sudoku: add number to a copy of the grid" tmcname='part05-11_sudoku_add_to_copy'>

Это последнее задание по судоку. В этот раз мы сделаем немного другую версию функции, добавляющей новые числа в сетку.

Функция `copy_and_add(sudoku: list, row_no: int, column_no: int, number: int)` принимает двумерный массив, представляющий сетку судоку, два целых числа — индекс строки и индекс столбца одной клетки — и одну цифру от 1 до 9. Функция должна _вернуть_ копию исходной сетки, в которой цифра добавлена в нужное место. При этом функция _не должна_ изменять исходную сетку, полученную аргументом.

Функция `print_sudoku` из предыдущего упражнения пригодится для тестирования; она используется в примере ниже:

```python
sudoku  = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
]

grid_copy = copy_and_add(sudoku, 0, 0, 2)
print("Original:")
print_sudoku(sudoku)
print()
print("Copy:")
print_sudoku(grid_copy)
```

<sample-output>

<pre>
Original:
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

Copy:
2 _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _
_ _ _  _ _ _  _ _ _

</pre>

</sample-output>

**Подсказка**
При работе со вложенными списками нужно особенно внимательно относиться к копированию. Что именно нужно копировать явно, и где на самом деле отражаются изменения? Здесь тоже отлично помогает [инструмент визуализации](http://www.pythontutor.com/visualize.html#mode=edit), хотя из‑за размера сетки судоку картинка будет менее аккуратной, чем обычно.

</programming-exercise>

<programming-exercise name='Крестики-нолики' anchor="Tic-Tac-Toe" tmcname='part05-12_tic_tac_toe'>

«Крестики-нолики» играются на поле 3×3. Два игрока по очереди ставят символы «нолик» и «крестик». Если одному из игроков удаётся выстроить три своих символа в ряд по любой строке, столбцу или диагонали, он побеждает. Если не удаётся никому — ничья.

Напишите функцию `play_turn(game_board: list, x: int, y: int, piece: str)`, которая ставит заданный символ в клетку с указанными координатами. Значения координат на поле — от 0 до 2.

**Важно:** по сравнению с упражнениями про судоку, здесь порядок координат обратный: сначала идёт столбец `x`, а затем строка `y`.

Поле состоит из следующих строковых значений:

* `""`: пустая клетка
* `"X"`: символ игрока 1
* `"O"`: символ игрока 2

Функция должна вернуть `True`, если клетка была пустой и символ удалось поставить. Функция должна вернуть `False`, если клетка занята или если координаты некорректны.

Пример работы функции:

```python
game_board = [["", "", ""], ["", "", ""], ["", "", ""]]
print(play_turn(game_board, 2, 0, "X"))
print(game_board)
```

<sample-output>

True
[['', '', 'X'], ['', '', ''], ['', '', '']]

</sample-output>

</programming-exercise>

<programming-exercise name='Транспонирование матрицы' anchor="Transpose a matrix" tmcname='part05-13_transpose_matrix'>

Напишите функцию `transpose(matrix: list)`, которая принимает двумерный массив целых чисел, то есть матрицу. Функция должна _транспонировать_ матрицу. Транспонирование — это «переворот» матрицы относительно главной диагонали: столбцы становятся строками, а строки — столбцами.

Можно считать, что матрица квадратная, то есть количество строк равно количеству столбцов.

Следующая матрица

```python
1 2 3
4 5 6
7 8 9
```

в транспонированном виде выглядит так:

```python
1 4 7
2 5 8
3 6 9
```

Функция не должна ничего возвращать. Матрицу нужно изменить напрямую через ссылку.

</programming-exercise>

## Побочные эффекты функций {#side-effects-of-functions}

Если функция получает ссылку на список, она может изменять этот список. Если программист не планировал прямых изменений, случайная модификация списка‑аргумента может привести к проблемам в других частях программы.

Рассмотрим функцию, которая должна находить второй по величине минимальный элемент списка:

```python
def second_smallest(my_list: list) -> int:
    # в отсортированном списке второй минимальный элемент находится по индексу 1
    my_list.sort()
    return my_list[1]

numbers = [1, 4, 2, 5, 3, 6, 4, 7]
print(second_smallest(numbers))
print(numbers)
```

<sample-output>
2
[1, 2, 3, 4, 4, 5, 6, 7]
</sample-output>

Функция действительно находит второй минимальный элемент, но при этом сортирует исходный список «на месте», меняя порядок элементов. Если порядок элементов важен в другой части программы, вызов такой функции может привести к ошибкам. Непреднамеренное изменение объекта, к которому обращаются по ссылке, называется _побочным эффектом_ (side effect) функции.

Избежать побочного эффекта можно, слегка изменив функцию:

```python
def second_smallest(my_list: list) -> int:
    list_copy = sorted(my_list)
    return list_copy[1]

numbers = [1, 4, 2, 5, 3, 6, 4, 7]
print(second_smallest(numbers))
print(numbers)
```

<sample-output>

2
[1, 4, 2, 5, 3, 6, 4, 7]

</sample-output>

Функция `sorted` возвращает новую отсортированную копию списка, поэтому поиск второго минимального элемента больше не нарушает порядок элементов исходного списка.

Обычно хорошей практикой считается избегать побочных эффектов в функциях. Побочные эффекты усложняют проверку того, что программа правильно работает во всех ситуациях.

Функции без побочных эффектов также называют _чистыми функциями_ (pure functions). Особенно в функциональном стиле программирования это считается важным идеалом. Подробнее мы разберём эту тему в курсе _Advanced Course in Programming_, который следует за этим курсом.

<!---
Тест для повторения материала этого раздела:

<quiz id="b254a4f9-09bb-55c8-87c0-538f91e51ace"></quiz>
-->
